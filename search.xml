<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringCloud 微服务入门：服务调用流程解析</title>
      <link href="/2025/01/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%EF%BC%9A%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/"/>
      <url>/2025/01/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%EF%BC%9A%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>目录</p><p><a href="#%E4%B8%80%E3%80%81%E5%BC%95%E8%A8%80">1、引言</a></p><p><a href="#%E4%BA%8C%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5">2、微服务基础概念</a></p><p><a href="#2.1%E3%80%81%E6%A1%86%E6%9E%B6%E6%80%BB%E8%A7%88">2.1、框架总览</a></p><p><a href="#2.2%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E7%9A%84%E5%AF%B9%E6%AF%94">2.2、微服务与单体架构的对比</a></p><p><a href="#%E4%B8%89%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9C%80%E5%A4%A7%E7%89%B9%E7%82%B9%EF%BC%9A%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E7%94%A8">3、微服务的最大特点：服务之间的调用</a></p><p><a href="#3.1%E3%80%81%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C">3.1、服务注册</a></p><p><a href="#3.1.1%E3%80%81%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86">3.1.1、注册中心原理</a></p><p><a href="#3.1.2%E3%80%81Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83">3.1.2、Nacos 注册中心</a></p><p><a href="#3.1.3%E3%80%81%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C">3.1.3、服务注册</a></p><p><a href="#3.2%E3%80%81%E6%9C%8D%E5%8A%A1%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F">3.2、服务间通信方式</a></p><p><a href="#3.2.1%E3%80%81OpenFeign">3.2.1、OpenFeign</a></p><p><a href="#3.2.2%E3%80%81RabbitMQ">3.2.2、RabbitMQ</a></p><p><a href="#3.2.3%E3%80%81SpringAMQP">3.2.3、SpringAMQP</a></p><p><a href="#3.3%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">3.3、负载均衡</a></p><p><a href="#3.3.1%E3%80%81%E6%BA%90%E7%A0%81%E8%B7%9F%E8%B8%AA">3.3.1、源码跟踪</a></p><p><a href="#3.3.2%E3%80%81NacosRule">3.3.2、NacosRule</a></p><p><a href="#3.4%E3%80%81%C2%A0%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%E6%9C%BA%E5%88%B6">3.4、 服务容错机制</a></p><p><a href="#3.4.1%E3%80%81%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4%E6%96%B9%E6%A1%88">3.4.1、服务保护方案</a></p><p><a href="#3.4.2%E3%80%81Sentinel">3.4.2、Sentinel</a></p><p><a href="#3.4.3%E3%80%81%E8%AF%B7%E6%B1%82%E9%99%90%E6%B5%81">3.4.3、请求限流</a></p><p><a href="#3.4.4%E3%80%81%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB">3.4.4、线程隔离</a></p><p><a href="#3.4.5%E3%80%81%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD">3.4.5、服务熔断</a></p><p><a href="#3.5%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1">3.5、分布式事务</a></p><p><a href="#3.5.1%E3%80%81Seata">3.5.1、Seata</a></p><p><a href="#3.5.2%E3%80%81XA%E6%A8%A1%E5%BC%8F">3.5.2、XA 模式</a></p><p><a href="#3.5.3%E3%80%81AT%E6%A8%A1%E5%BC%8F">3.5.3、AT 模式</a></p><p><a href="#%E5%9B%9B%E3%80%81%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA%EF%BC%9A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B">4、案例演示：微服务调用的完整流程</a></p><p><a href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93">5、结语</a></p><h2 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h2><blockquote><p>在当今的软件开发领域，微服务架构已经成为一种热门的设计模式。与传统的单体架构相比，微服务架构通过将系统拆分为多个小而独立的服务，使得开发、部署和维护变得更加灵活。这种架构设计不仅能够适应现代互联网应用的快速变化需求，还能在一定程度上缓解开发团队之间的协作冲突。<br>但同时，微服务也引入了许多新的挑战，其中最核心的一个问题就是服务之间的相互调用。在单体架构中，模块之间的调用通常是本地方法的调用，简单而高效。而在微服务架构中，不同服务运行在独立的进程中，甚至可能分布在不同的服务器上，服务之间的通信需要通过网络来实现，这无疑增加了复杂性。<br>在这篇文章中，我们将围绕微服务架构的基础概念展开，重点探讨其与单体项目的主要不同点，尤其是服务之间的调用逻辑。通过一个简单的案例，我们会展示 SpringCloud 框架下服务调用的完整流程，帮助你快速理解微服务。</p></blockquote><h2 id="2、微服务基础概念"><a href="#2、微服务基础概念" class="headerlink" title="2、微服务基础概念"></a>2、微服务基础概念</h2><h3 id="2-1、框架总览"><a href="#2-1、框架总览" class="headerlink" title="2.1、框架总览"></a>2.1、框架总览</h3><blockquote><p>首先要了解什么是微服务就需要对其整体框架有一个全局的概念，下面这张概述图详细的展示了微服务的大体框架：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_6c17275f.png" alt="pic_6c17275f.png"></p><blockquote><p>可以发现微服务涉及的相关组件还是蛮多的，相较于单体项目终端直接与数据库相连，中间最多加个网关，微服务由于其服务之间的隔离性，导致其相互调用成了一个比较麻烦的问题，随之而来的还有一大堆分布式事务相关的安全问题。</p></blockquote><blockquote><p>本文主要对控制面、治理面和数据面进行讲解，涉及到的组件有：</p><ul><li>Nacos</li><li>Sentinel</li><li>GateWay 网关</li><li>OpenFeign</li><li>RabbitMQ</li></ul></blockquote><h3 id="2-2、微服务与单体架构的对比"><a href="#2-2、微服务与单体架构的对比" class="headerlink" title="2.2、微服务与单体架构的对比"></a>2.2、微服务与单体架构的对比</h3><table>  <tbody>   <tr>    <td>特性</td>    <td>单体架构</td>    <td>微服务架构</td>   </tr>   <tr>    <td>开发</td>    <td>所有模块集中在一个代码库中，协作紧密</td>    <td>各模块独立开发，松耦合</td>   </tr>   <tr>    <td>部署</td>    <td>整体部署，一次更新影响整个系统</td>    <td>独立部署，每个服务可以单独更新</td>   </tr>   <tr>    <td>扩展</td>    <td>水平扩展整个应用，浪费资源</td>    <td>精确扩展特定服务，资源利用率更高</td>   </tr>   <tr>    <td>技术栈</td>    <td>单一技术栈，统一性强</td>    <td>多样化技术栈，根据服务需求灵活选择</td>   </tr>  </tbody> </table><h2 id="3、微服务的最大特点：服务之间的调用"><a href="#3、微服务的最大特点：服务之间的调用" class="headerlink" title="3、微服务的最大特点：服务之间的调用"></a>3、微服务的最大特点：服务之间的调用</h2><blockquote><p>在微服务架构中，服务之间的调用是系统运行的核心，也是微服务架构与单体架构最大的区别之一。由于服务运行在不同的进程中，甚至分布在不同的服务器上，其通信方式需要考虑网络传输的复杂性。以下是微服务调用的几个关键要素以及相关组件：</p></blockquote><h3 id="3-1、服务注册"><a href="#3-1、服务注册" class="headerlink" title="3.1、服务注册"></a>3.1、服务注册</h3><blockquote><p>在微服务架构中，每个服务可能动态变化（如启动、关闭或迁移）。为了实现服务之间的通信，首先需要一个机制来注册和发现服务。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_ee9bc610.png" alt="pic_ee9bc610.png"></p><h4 id="3-1-1、注册中心原理"><a href="#3-1-1、注册中心原理" class="headerlink" title="3.1.1、注册中心原理"></a>3.1.1、注册中心原理</h4><blockquote><p>举个例子，在微服务远程调用的过程中，包括两个角色：</p><ul><li>服务提供者：提供接口供其它微服务访问，比如 <code>item-service</code></li><li>服务消费者：调用其它微服务提供的接口，比如 <code>cart-service</code></li></ul></blockquote><blockquote><p>在大型微服务项目中，服务提供者的数量会非常多，为了管理这些服务就引入了注册中心的概念。注册中心、服务提供者、服务消费者三者间关系如下：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_e4133fd6.png" alt="pic_e4133fd6.png"></p><blockquote><p>流程如下：</p><ul><li>服务启动时就会注册自己的服务信息（服务名、IP、端口）到注册中心</li><li>调用者可以从注册中心订阅想要的服务，获取服务对应的实例列表（1 个服务可能多实例部署）</li><li>调用者自己对实例列表负载均衡，挑选一个实例</li><li>调用者向该实例发起远程调用</li></ul></blockquote><blockquote><p>当服务提供者的实例宕机或者启动新实例时，调用者如何得知呢？</p><ul><li>服务提供者会定期向注册中心发送请求，报告自己的健康状态（心跳请求）</li><li>当注册中心长时间收不到提供者的心跳时，会认为该实例宕机，将其从服务的实例列表中剔除</li><li>当服务有新实例启动时，会发送注册服务请求，其信息会被记录在注册中心的服务实例列表</li><li>当注册中心服务列表变更时，会主动通知微服务，更新本地服务列表</li></ul></blockquote><h4 id="3-1-2、Nacos-注册中心"><a href="#3-1-2、Nacos-注册中心" class="headerlink" title="3.1.2、Nacos 注册中心"></a>3.1.2、Nacos 注册中心</h4><blockquote><p>目前开源的注册中心框架有很多，国内比较常见的有：</p><ul><li>Eureka：Netflix 公司出品，目前被集成在 SpringCloud 当中，一般用于 Java 应用</li><li>Nacos：Alibaba 公司出品，目前被集成在 SpringCloudAlibaba 中，一般用于 Java 应用</li><li>Consul：HashiCorp 公司出品，目前集成在 SpringCloud 中，不限制微服务语言</li></ul></blockquote><blockquote><p>由于 Nacos 是国内产品，中文文档比较丰富，而且同时具备配置管理功能，所以使用较多。下面来讲一下怎么部署 Nacos，推荐是使用 linux 虚拟机结合 docker 来进行部署，这里就不详细演示怎么安装 docker 了，有需要的可以去看一下我之前写的博客，这里就直接参考 Nacos 官网进行安装：</p></blockquote><p><a href="https://nacos.io/docs/latest/quickstart/quick-start">Nacos 快速开始 | Nacos 官网这个快速开始手册是帮忙您快速在您的电脑上，下载、安装并使用 Nacos。https://nacos.io/docs/latest/quickstart/quick-start<img src="https://api.smain.cn/pics/pic_6feeb0fa.png" alt="pic_6feeb0fa.png">https://nacos.io/docs/latest/quickstart/quick-start</a><img src="https://api.smain.cn/pics/pic_e8d7d828.png" alt="pic_e8d7d828.png"></p><p>解压到非中文路径下：</p><p><img src="https://api.smain.cn/pics/pic_397574c9.png" alt="pic_397574c9.png"></p><p><img src="https://api.smain.cn/pics/pic_1dbd4962.png" alt="pic_1dbd4962.png"></p><p>打开编辑，在开头处加入如下内容:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 1999-2018 Alibaba Group Holding Ltd.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> # 以下内容需手动加入</span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> `nacos_config`;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE `nacos_config` <span class="keyword">DEFAULT</span> <span class="keyword">character set</span> utf8mb4;</span><br><span class="line"><span class="keyword">SET</span> names utf8mb4;</span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">USE `nacos_config`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br></pre></td></tr></table></figure><p>然后打开你的数据库将脚本导入创建 nacos 数据库：</p><p><img src="https://api.smain.cn/pics/pic_06de63c9.png" alt="pic_06de63c9.png"></p><p>修改数据库连接默认配置：</p><p><img src="https://api.smain.cn/pics/pic_28c31890.png" alt="pic_28c31890.png"></p><p><img src="https://api.smain.cn/pics/pic_a698e5e1.png" alt="pic_a698e5e1.png"></p><p>启动后访问 localhost:8848&#x2F;nacos ：</p><p><img src="https://api.smain.cn/pics/pic_98c3381a.png" alt="pic_98c3381a.png"></p><h4 id="3-1-3、服务注册"><a href="#3-1-3、服务注册" class="headerlink" title="3.1.3、服务注册"></a>3.1.3、服务注册</h4><blockquote><p>接下来就是在你的项目中添加依赖并进行配置：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--nacos 服务注册发现--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: item-service # 服务名称</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8848</span> # nacos地址</span><br></pre></td></tr></table></figure><p><img src="https://api.smain.cn/pics/pic_6b15c275.png" alt="pic_6b15c275.png"></p><h3 id="3-2、服务间通信方式"><a href="#3-2、服务间通信方式" class="headerlink" title="3.2、服务间通信方式"></a>3.2、服务间通信方式</h3><blockquote><p>微服务之间的通信主要有以下两种方式：</p><ul><li>同步调用（HTTP REST）：使用轻量级的 HTTP 协议，适合请求-响应模式。SpringCloud 提供了 OpenFeign 组件用于简化 REST 调用，通过声明式接口实现服务间的远程调用。</li><li>异步调用（消息队列）：通过消息中间件实现异步通信和解耦，适合事件驱动的场景。RabbitMQ：一个流行的开源消息队列，支持 AMQP 协议，具有高性能、可靠性和灵活性，常用于实现微服务间的异步通信和事件通知。</li></ul></blockquote><h4 id="3-2-1、OpenFeign"><a href="#3-2-1、OpenFeign" class="headerlink" title="3.2.1、OpenFeign"></a>3.2.1、OpenFeign</h4><blockquote><p>其实远程调用的关键点就在于四个：</p><ol><li>请求方式</li><li>请求路径</li><li>请求参数</li><li>返回值类型</li></ol></blockquote><blockquote><p>所以，OpenFeign 就利用 SpringMVC 的相关注解来声明上述 4 个参数，然后基于动态代理帮我们生成远程调用的代码，而无需我们手动再编写，非常方便。</p><p>需要注意的是，调用方也要像刚才那样引入 nacos 依赖并进行配置，接下来，我们就通过一个快速入门的案例来体验一下 OpenFeign 的便捷吧。</p></blockquote><p>首先还是在调用方引入依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--openFeign--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;!--负载均衡器--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意这里服务之间的调用涉及到了负载均衡，所以也要把 loadbalancer 的依赖也引入，关于负载均衡的讲解放到了后面。</p></blockquote><p>在调用者的启动类上添加注解，启动 OpenFeign 功能：</p><p><img src="https://api.smain.cn/pics/pic_c4a34833.png" alt="pic_c4a34833.png"></p><p>然后新建一个 client 包，里面放访问客户端：</p><p><img src="https://api.smain.cn/pics/pic_6c587f75.png" alt="pic_6c587f75.png"></p><blockquote><p>这里只需要声明接口，无需实现方法，因为 OpenFeign 基于 Nacos 的远程调用原理是 声明式 HTTP 调用 + 动态服务发现，通过动态代理、Nacos 的服务注册与发现，以及负载均衡等机制实现服务之间的无缝通信。具体流程后面会讲到。</p></blockquote><blockquote><p>接口中的几个关键信息：</p><ul><li>@FeignClient(“item-service”) ：声明服务名称</li><li>@GetMapping ：声明请求方式</li><li>@GetMapping(“&#x2F;items”) ：声明请求路径</li><li>@RequestParam(“ids”) Collection<Long> ids ：声明请求参数</li><li>List<ItemDTO> ：返回值类型</li></ul><p>有了上述信息，OpenFeign 就可以利用动态代理帮我们实现这个方法，并且向 <a href="http://item-service/items">http://item-service/items</a> 发送一个 GET 请求，携带 ids 为请求参数，并自动将返回值处理为 List<ItemDTO>。</p><p>我们只需要直接调用这个方法，即可实现远程调用了。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_53b9572b.png" alt="pic_53b9572b.png"></p><p><img src="https://api.smain.cn/pics/pic_aee1db5c.png" alt="pic_aee1db5c.png"></p><blockquote><p>当然涉及到多线程必然要考虑性能的问题，OpenFeign 也支持线程池，在调用者端引入依赖并进行配置即可生效还是非常方便的。</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#.xml</span><br><span class="line"><span class="comment">&lt;!--OK http 的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#.yaml</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启OKHttp功能</span></span><br></pre></td></tr></table></figure><h4 id="3-2-2、RabbitMQ"><a href="#3-2-2、RabbitMQ" class="headerlink" title="3.2.2、RabbitMQ"></a>3.2.2、RabbitMQ</h4><blockquote><p>前面我们了解了同步调用，在讲解异步调用之前，首先还是来看一下它们各自的优缺点：</p></blockquote><table>  <tbody>   <tr>    <td>特性</td>    <td>同步调用</td>    <td>异步调用</td>   </tr>   <tr>    <td>定义</td>    <td>调用方发出请求后会等待响应完成，才能继续执行后续逻辑。</td>    <td>调用方发出请求后无需等待响应，可立即继续执行其他任务。</td>   </tr>   <tr>    <td>通信协议</td>    <td>通常基于 HTTP 或 RPC</td>    <td>通常基于消息队列（如 RabbitMQ、Kafka 等）。</td>   </tr>   <tr>    <td>耦合度</td>    <td>服务间紧密耦合，调用方需要直接知道服务提供方的信息。</td>    <td>服务间松耦合，通过消息中间件解耦。</td>   </tr>   <tr>    <td>实时性</td>    <td>响应实时性高，适合对结果有即时需求的场景。</td>    <td>延迟容忍度高，适合对结果实时性要求不高的场景。</td>   </tr>   <tr>    <td>可靠性</td>    <td>如果服务不可用，调用会失败，需要结合重试机制或熔断处理。</td>    <td>消息通常持久化存储，可靠性高，即使目标服务暂时不可用，消息不会丢失。</td>   </tr>  </tbody> </table><p><img src="https://api.smain.cn/pics/pic_2b9a1a0f.png" alt="pic_2b9a1a0f.png"></p><p><img src="https://api.smain.cn/pics/pic_4b9baabb.png" alt="pic_4b9baabb.png"></p><blockquote><p>异步调用方式其实就是基于消息通知的方式，一般包含三个角色：</p><ol><li>消息发送者：投递消息的人，就是原来的调用方</li><li>消息 Broker：管理、暂存、转发消息，你可以把它理解成微信服务器</li><li>消息接收者：接收和处理消息的人，就是原来的服务提供方</li></ol></blockquote><p><img src="https://api.smain.cn/pics/pic_1c3d2652.png" alt="pic_1c3d2652.png"></p><blockquote><p>在异步调用中，发送者不再直接同步调用接收者的业务接口，而是发送一条消息投递给消息 Broker。然后接收者根据自己的需求从消息 Broker 那里订阅消息。每当发送方发送消息后，接受者都能获取消息并处理。这样，发送消息的人和接收消息的人就完全解耦了。</p></blockquote><blockquote><p>核心思想就是只将关键服务同步调用，而其他一些不太重要的就交给 Broker 异步调用！</p></blockquote><blockquote><p>当然，异步通信也并非完美无缺，它存在下列缺点：</p><ul><li>完全依赖于 Broker 的可靠性、安全性和性能</li><li>架构复杂，后期维护和调试麻烦</li></ul></blockquote><blockquote><p>安装过程这里就不演示了，推荐使用 docker 容器隔离环境，登录后界面如图：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_0b08feb6.png" alt="pic_0b08feb6.png"></p><p>RabbitMQ 对应的架构如图：</p><p><img src="https://api.smain.cn/pics/pic_b98c3ace.png" alt="pic_b98c3ace.png"></p><blockquote><p>其中包含几个概念：</p><ul><li>publisher：生产者，也就是发送消息的一方</li><li>consumer：消费者，也就是消费消息的一方</li><li>queue：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li>exchange：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。</li><li>virtual host：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的 exchange、queue(有点像 mysql 里的 database，不同的项目的 database 相互隔离)</li></ul><p>上述这些东西都可以在 RabbitMQ 的管理控制台来管理.</p></blockquote><blockquote><p>其中交换机和队列要建立绑定关系后才能传递信息，这个时候如果有消费者监听了 MQ 的队列，自然就能收到消息了。</p></blockquote><h4 id="3-2-3、SpringAMQP"><a href="#3-2-3、SpringAMQP" class="headerlink" title="3.2.3、SpringAMQP"></a>3.2.3、SpringAMQP</h4><blockquote><p>将来我们开发业务功能的时候，肯定不会在控制台收发消息，而是应该基于编程的方式。由于 RabbitMQ 采用了 AMQP 协议，因此它具备跨语言的特性。任何语言只要遵循 AMQP 协议收发消息，都可以与 RabbitMQ 交互。并且 RabbitMQ 官方也提供了各种不同语言的客户端。</p><p>但是，RabbitMQ 官方提供的 Java 客户端编码相对复杂，一般生产环境下我们更多会结合 Spring 来使用。而 Spring 的官方刚好基于 RabbitMQ 提供了这样一套消息收发的模板工具：SpringAMQP。并且还基于 SpringBoot 对其实现了自动装配，使用起来非常方便。</p></blockquote><blockquote><p>SpringAMQP 提供了三个功能：</p><ol><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了 RabbitTemplate 工具，用于发送消息</li></ol></blockquote><p>SpringAMQP 如何收发消息？</p><p>1、引入 spring-boot-starter-amqp 依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、配置 rabbitmq 服务端信息</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.36</span><span class="number">.8</span> <span class="comment"># 你的虚拟机IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/hmall</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">test</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>3、利用 RabbitTemplate 发送消息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimpleQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>4、利用@RabbitListener 注解声明要监听的队列，监听消息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用RabbitListener来声明要监听的队列信息</span></span><br><span class="line">    <span class="comment">// 将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。</span></span><br><span class="line">    <span class="comment">// 可以看到方法体中接收的就是消息体的内容</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://api.smain.cn/pics/pic_62994edd.png" alt="pic_62994edd.png"></p><blockquote><p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用 work 模型，多个消费者共同处理消息处理，消息处理的速度就能大大提高了，简单来说就是让多个消费者绑定到一个队列，共同消费队列中的消息。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_94df481c.png" alt="pic_94df481c.png"></p><blockquote><p>交换机的类型有很多其特点也是各不相同，不仅如此关于 RabbitMQ 还有很多的内容，像如何确保 MQ 消息的可靠性，以及消息发送失败后的处理方案和延迟消息，这里就不详细展开了。</p></blockquote><h3 id="3-3、负载均衡"><a href="#3-3、负载均衡" class="headerlink" title="3.3、负载均衡"></a>3.3、负载均衡</h3><blockquote><p>我们知道微服务间远程同步调用都是由 OpenFeign 帮我们完成的，甚至帮我们实现了服务列表之间的负载均衡。但具体负载均衡的规则是什么呢？何时做的负载均衡呢？</p><p>接下来我们一起来分析一下。</p></blockquote><h4 id="3-3-1、源码跟踪"><a href="#3-3-1、源码跟踪" class="headerlink" title="3.3.1、源码跟踪"></a>3.3.1、源码跟踪</h4><p>首先来梳理一下远程调用的步骤：</p><p><img src="https://api.smain.cn/pics/pic_5cf6fee9.png" alt="pic_5cf6fee9.png"></p><p>整体流程如下图所示：</p><p><img src="https://api.smain.cn/pics/pic_4f5eba2e.png" alt="pic_4f5eba2e.png"></p><blockquote><p>可以看到 <code>FeignBlockingLoadBalancerClient</code> 是一个适配器，内部使用了 <code>LoadBalancerClient</code> 来实现服务实例的选择和请求的负载均衡处理。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_1e244f9f.png" alt="pic_1e244f9f.png"></p><p>我们跟进去发现 <code>LoadBalancerClient 接口</code>只有一个实现类就是 BlockingLoadBalancerClient：</p><p><img src="https://api.smain.cn/pics/pic_855654a2.png" alt="pic_855654a2.png"></p><p>其中的 choose 方法实现了负载均衡：</p><p><img src="https://api.smain.cn/pics/pic_185d4835.png" alt="pic_185d4835.png"></p><p>我们继续跟进：</p><p><img src="https://api.smain.cn/pics/pic_45dbc134.png" alt="pic_45dbc134.png"></p><blockquote><p>ReactiveLoadBalancer 是 Spring-Cloud-Common 组件中定义的负载均衡器接口规范，而 Spring-Cloud-Loadbalancer 组件给出了两个实现：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_a9d3ab98.png" alt="pic_a9d3ab98.png"></p><p>默认的实现是 RoundRobinLoadBalancer，即轮询负载均衡器。负载均衡器的核心逻辑如下：</p><p><img src="https://api.smain.cn/pics/pic_a7f74d43.png" alt="pic_a7f74d43.png"></p><p>这里的 ServiceInstanceListSupplier（服务拉取）也有很多实现：</p><p><img src="https://api.smain.cn/pics/pic_227eaadd.png" alt="pic_227eaadd.png"></p><blockquote><p>其中 CachingServiceInstanceListSupplier 采用了装饰模式，加了服务实例列表缓存，避免每次都要去注册中心拉取服务实例列表。而其内部是基于<code>DiscoveryClientServiceInstanceListSupplier</code>来实现的。</p><p>在这个类的构造函数中，就会异步的基于 DiscoveryClient 去拉取服务的实例列表：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_3f787f7a.png" alt="pic_3f787f7a.png"></p><h4 id="3-3-2、NacosRule"><a href="#3-3-2、NacosRule" class="headerlink" title="3.3.2、NacosRule"></a>3.3.2、NacosRule</h4><blockquote><p>之前分析源码的时候我们发现负载均衡的算法是有<code>ReactiveLoadBalancer</code>来定义的，我们发现它的实现类有三个：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_bb776c1b.png" alt="pic_bb776c1b.png"></p><blockquote><p>其中<code>RoundRobinLoadBalancer</code>和<code>RandomLoadBalancer</code>是由<code>Spring-Cloud-Loadbalancer</code>模块提供的，而<code>NacosLoadBalancer</code>则是由<code>Nacos-Discorvery</code>模块提供的。</p><p>默认采用的负载均衡策略是<code>RoundRobinLoadBalancer</code>，那如果我们要切换负载均衡策略该怎么办？</p></blockquote><p>查看源码会发现，<code>Spring-Cloud-Loadbalancer</code>模块中有一个自动配置类：</p><p><img src="https://api.smain.cn/pics/pic_f17d0a34.png" alt="pic_f17d0a34.png"></p><p>其中定义了默认的负载均衡器：</p><p><img src="https://api.smain.cn/pics/pic_3d5b50d2.png" alt="pic_3d5b50d2.png"></p><blockquote><p>这个 Bean 上添加了<code>@ConditionalOnMissingBean</code>注解，也就是说如果我们自定义了这个类型的 bean，则负载均衡的策略就会被改变。</p><p>这个配置类千万不要加@Configuration 注解，也不要被 SpringBootApplication 扫描到。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_88dcedb4.png" alt="pic_88dcedb4.png"></p><blockquote><p>由于这个 OpenFeignConfig 没有加@Configuration 注解，也就没有被 Spring 加载，因此是不会生效的。接下来，我们要在启动类上通过注解来声明这个配置。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_0c5b3c7c.png" alt="pic_0c5b3c7c.png"></p><blockquote><p><code>RoundRobinLoadBalancer</code>是轮询算法，<code>RandomLoadBalancer</code>是随机算法，那么<code>NacosLoadBalancer</code>是什么负载均衡算法呢？</p></blockquote><blockquote><p>简单来说<code>NacosLoadBalancer</code>是一个基于权重的加权平均算法，我们打开 nacos 控制台，进入<code>item-service</code>的服务详情页，可以看到每个实例后面都有一个编辑按钮，在这里就可以修改每个服务的权重了：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_b1638609.png" alt="pic_b1638609.png"></p><h3 id="3-4、-服务容错机制"><a href="#3-4、-服务容错机制" class="headerlink" title="3.4、 服务容错机制"></a>3.4、 服务容错机制</h3><blockquote><p>由于微服务通信依赖于网络，可能会出现超时、失败等问题。服务容错机制可以保证系统的稳定性。</p></blockquote><h4 id="3-4-1、服务保护方案"><a href="#3-4-1、服务保护方案" class="headerlink" title="3.4.1、服务保护方案"></a>3.4.1、服务保护方案</h4><blockquote><p>微服务保护的方案有很多，比如：</p><ul><li>请求限流</li><li>线程隔离</li><li>服务熔断</li></ul></blockquote><blockquote><p>这些方案或多或少都会导致服务的体验上略有下降，比如请求限流，降低了并发上限；线程隔离，降低了可用资源数量；服务熔断，降低了服务的完整度，部分服务变的不可用或弱可用。因此这些方案都属于服务降级的方案。但通过这些方案，服务的健壮性得到了提升，接下来，我们就逐一了解这些方案的原理。</p></blockquote><p>请求限流</p><blockquote><p>服务故障最重要原因，就是并发太高！解决了这个问题，就能避免大部分故障。当然，接口的并发不是一直很高，而是突发的。因此请求限流，就是限制或控制接口访问的并发流量，避免服务因流量激增而出现故障。</p><p>请求限流往往会有一个限流器，数量高低起伏的并发请求曲线，经过限流器就变的非常平稳。这就像是水电站的大坝，起到蓄水的作用，可以通过开关控制水流出的大小，让下游水流始终维持在一个平稳的量。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_5dcdac23.png" alt="pic_5dcdac23.png"></p><p>线程隔离</p><blockquote><p>当一个业务接口响应时间长，而且并发高时，就可能耗尽服务器的线程资源，导致服务内的其它接口受到影响。所以我们必须把这种影响降低，或者缩减影响的范围。线程隔离正是解决这个问题的好办法。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_7a459a49.png" alt="pic_7a459a49.png"></p><p>服务熔断</p><blockquote><p>线程隔离虽然避免了雪崩问题，但故障服务依然会拖慢服务调用方的接口响应速度，这个时候就需要进行熔断以拒绝调用该接口。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_3f36eb3c.png" alt="pic_3f36eb3c.png"></p><h4 id="3-4-2、Sentinel"><a href="#3-4-2、Sentinel" class="headerlink" title="3.4.2、Sentinel"></a>3.4.2、Sentinel</h4><blockquote><p>Sentinel 是阿里巴巴开源的一款 分布式系统流量防护组件，主要用于实现流量控制（Flow Control）、熔断降级（Circuit Breaking）和系统自适应保护（System Adaptive Protection）等功能，是保障微服务系统稳定性的重要工具。</p></blockquote><p>下载地址：</p><p><a href="https://github.com/alibaba/Sentinel/releases">Releases · alibaba&#x2F;Sentinel (github.com)https://github.com/alibaba/Sentinel/releases<img src="https://api.smain.cn/pics/pic_da463f82.png" alt="pic_da463f82.png">https://github.com/alibaba/Sentinel/releases</a>然后运行如下命令启动控制台：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -Dserver.port=<span class="number">8090</span> -Dcsp.sentinel.dashboard.server=localhost:<span class="number">8090</span> -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar</span><br></pre></td></tr></table></figure><p>建议是写成.bat 文件然后双击启动：</p><p><img src="https://api.smain.cn/pics/pic_74b39e89.png" alt="pic_74b39e89.png"></p><p>访问<a href="http://localhost:8080/">http://localhost:8090</a>页面，就可以看到 sentinel 的控制台了：</p><p>需要输入账号和密码，默认都是：sentinel</p><p><img src="https://api.smain.cn/pics/pic_4fbc2f32.png" alt="pic_4fbc2f32.png"></p><blockquote><p>然后就是整合到你的项目中去，引入依赖并修改配置文件</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--sentinel--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8090</span></span><br><span class="line">      <span class="attr">http-method-specify:</span> <span class="literal">true</span> <span class="comment"># 开启请求方式前缀</span></span><br></pre></td></tr></table></figure><p><img src="https://api.smain.cn/pics/pic_1681c221.png" alt="pic_1681c221.png"></p><h4 id="3-4-3、请求限流"><a href="#3-4-3、请求限流" class="headerlink" title="3.4.3、请求限流"></a>3.4.3、请求限流</h4><p>直接在 sentinel 设置就行：</p><p><img src="https://api.smain.cn/pics/pic_6b3f9dfd.png" alt="pic_6b3f9dfd.png"></p><p><img src="https://api.smain.cn/pics/pic_ec3ef67d.png" alt="pic_ec3ef67d.png"></p><h4 id="3-4-4、线程隔离"><a href="#3-4-4、线程隔离" class="headerlink" title="3.4.4、线程隔离"></a>3.4.4、线程隔离</h4><p><img src="https://api.smain.cn/pics/pic_e9f1eede.png" alt="pic_e9f1eede.png"></p><blockquote><p>总的处理能力等于并发线程数乘上单机 QPS</p></blockquote><p><img src="https://api.smain.cn/pics/pic_daf71bfb.png" alt="pic_daf71bfb.png"></p><h4 id="3-4-5、服务熔断"><a href="#3-4-5、服务熔断" class="headerlink" title="3.4.5、服务熔断"></a>3.4.5、服务熔断</h4><p><img src="https://api.smain.cn/pics/pic_31fb73f1.png" alt="pic_31fb73f1.png"></p><p><img src="https://api.smain.cn/pics/pic_f33fbd76.png" alt="pic_f33fbd76.png"></p><h3 id="3-5、分布式事务"><a href="#3-5、分布式事务" class="headerlink" title="3.5、分布式事务"></a>3.5、分布式事务</h3><h4 id="3-5-1、Seata"><a href="#3-5-1、Seata" class="headerlink" title="3.5.1、Seata"></a>3.5.1、Seata</h4><blockquote><p>解决分布式事务的方案有很多，但实现起来都比较复杂，因此我们一般会使用开源的框架来解决分布式事务问题。在众多的开源分布式事务框架中，功能最完善、使用最多的就是阿里巴巴在 2019 年开源的 Seata 了。</p></blockquote><p><a href="https://seata.apache.org/zh-cn/docs/overview/what-is-seata/">Seata 是什么？ | Apache Seatahttps://seata.apache.org/zh-cn/docs/overview/what-is-seata/<img src="https://api.smain.cn/pics/pic_f30f1de4.png" alt="pic_f30f1de4.png">https://seata.apache.org/zh-cn/docs/overview/what-is-seata/</a></p><blockquote><p>其实分布式事务产生的一个重要原因，就是参与事务的多个分支事务互相无感知，不知道彼此的执行状态。因此解决分布式事务的思想非常简单：</p><p>就是找一个统一的事务协调者，与多个分支事务通信，检测每个分支事务的执行状态，保证全局事务下的每一个分支事务同时成功或失败即可。大多数的分布式事务框架都是基于这个理论来实现的。</p></blockquote><blockquote><p>Seata 也不例外，在 Seata 的事务管理中有三个重要的角色：</p><ol><li>TC (Transaction Coordinator) - 事务协调者：维护全局和分支事务的状态，协调全局事务提交或回滚。</li><li>TM (Transaction Manager) - 事务管理器：定义全局事务的范围、开始全局事务、提交或回滚全局事务。</li><li>RM (Resource Manager) - 资源管理器：管理分支事务，与 TC 交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li></ol></blockquote><p>Seata 的工作架构如图所示：</p><p><img src="https://api.smain.cn/pics/pic_e60aa4cf.png" alt="pic_e60aa4cf.png"></p><blockquote><p>其中，TM 和 RM 可以理解为 Seata 的客户端部分，引入到参与事务的微服务依赖中即可。将来 TM 和 RM 就会协助微服务，实现本地分支事务与 TC 之间交互，实现事务的提交或回滚。而 TC 服务则是事务协调中心，是一个独立的微服务，需要单独部署。</p></blockquote><blockquote><p>将 seata 部署然后访问（需要注意，要确保 nacos、mysql 都在同一个网络中）：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_d07a654e.png" alt="pic_d07a654e.png"></p><p>微服务集成 Seata</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--seata--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">registry:</span> <span class="comment"># TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span> <span class="comment"># 注册中心类型 nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.36</span><span class="number">.8</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">&quot;&quot;</span> <span class="comment"># namespace，默认为空</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span> <span class="comment"># 分组，默认是DEFAULT_GROUP</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-server</span> <span class="comment"># seata服务名称</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">hmall</span> <span class="comment"># 事务组名称</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span> <span class="comment"># 事务组与tc集群的映射关系</span></span><br><span class="line">      <span class="attr">hmall:</span> <span class="string">&quot;default&quot;</span></span><br><span class="line">  <span class="attr">data-source-proxy-mode:</span> <span class="string">XA</span></span><br></pre></td></tr></table></figure><h4 id="3-5-2、XA-模式"><a href="#3-5-2、XA-模式" class="headerlink" title="3.5.2、XA 模式"></a>3.5.2、XA 模式</h4><p><img src="https://api.smain.cn/pics/pic_e6d9217e.png" alt="pic_e6d9217e.png"></p><blockquote><p>RM 一阶段的工作：</p><ul><li>注册分支事务到 TC</li><li>执行分支业务 sql 但不提交</li><li>报告执行状态到 TC</li></ul><p>TC 二阶段的工作：</p><p>TC 检测各分支事务执行状态</p><ul><li>如果都成功，通知所有 RM 提交事务</li><li>如果有失败，通知所有 RM 回滚事务</li></ul><p>RM 二阶段的工作：</p><ul><li>接收 TC 指令，提交或回滚事务</li></ul></blockquote><p>进行测试，可以发现事务成功回滚：</p><p><img src="https://api.smain.cn/pics/pic_94cbcb7b.png" alt="pic_94cbcb7b.png"></p><blockquote><p>XA 模式的优点是什么？</p><ul><li>事务的强一致性，满足 ACID 原则</li><li>常用数据库都支持，实现简单，并且没有代码侵入</li></ul><p>XA 模式的缺点是什么？</p><ul><li>因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差</li><li>依赖关系型数据库实现事务</li></ul></blockquote><h4 id="3-5-3、AT-模式"><a href="#3-5-3、AT-模式" class="headerlink" title="3.5.3、AT 模式"></a>3.5.3、AT 模式</h4><blockquote><p>AT 模式同样是分阶段提交的事务模型，不过缺弥补了 XA 模型中资源锁定周期过长的缺陷。</p></blockquote><p>Seata 的 AT 模型：</p><p><img src="https://api.smain.cn/pics/pic_b8633d02.png" alt="pic_b8633d02.png"></p><blockquote><p>阶段一 RM 的工作：</p><ul><li>注册分支事务</li><li>记录 undo-log（数据快照）</li><li>执行业务 sql 并提交</li><li>报告事务状态</li></ul><p>阶段二提交时 RM 的工作：</p><ul><li>删除 undo-log 即可</li></ul><p>阶段二回滚时 RM 的工作：</p><ul><li>根据 undo-log 恢复数据到更新前</li></ul></blockquote><p>AT 模式与 XA 模式的最大区别：</p><table>  <tbody>   <tr>    <td>维度</td>    <td>AT 模式</td>    <td>XA 模式</td>   </tr>   <tr>    <td>锁定范围</td>    <td>业务逻辑层的状态，锁定时间短</td>    <td>数据库资源（行或表），锁定时间长</td>   </tr>   <tr>    <td>一致性</td>    <td>最终一致性，通过补偿机制实现</td>    <td>强一致性，依赖数据库的两阶段提交</td>   </tr>  </tbody> </table><h2 id="4、案例演示：微服务调用的完整流程"><a href="#4、案例演示：微服务调用的完整流程" class="headerlink" title="4、案例演示：微服务调用的完整流程"></a>4、案例演示：微服务调用的完整流程</h2><blockquote><p>这一部分我将通过消息队列对服务之间的异步调用进行演示，同时讲一下延迟消息的实现。</p></blockquote><p>先让我们来看一下什么是延迟消息：</p><p><img src="https://api.smain.cn/pics/pic_14547a3b.png" alt="pic_14547a3b.png"></p><p><img src="https://api.smain.cn/pics/pic_b350093e.png" alt="pic_b350093e.png"></p><blockquote><p>其中 ttl.queue 队列由于没用消费者监听，那么它的消息就会成为死信，我们将其绑定到对应的死信交换机上，这个时候如果由消费者来监听就能够成功接收消息，但是此时距离消息发送已经过去了一段时间，所以产生了延时。</p></blockquote><blockquote><p>但是！基于死信队列虽然可以实现延迟消息，但太麻烦了。因此 RabbitMQ 社区提供了一个延迟消息插件来实现相同的效果。</p></blockquote><p><a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">rabbitmq&#x2F;rabbitmq-delayed-message-exchange: Delayed Messaging for RabbitMQ (github.com)https://github.com/rabbitmq/rabbitmq-delayed-message-exchange<img src="https://api.smain.cn/pics/pic_cd3d336a.png" alt="pic_cd3d336a.png">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange</a>这样我们就能够使用注解的方式直接发送延时消息了：</p><p><img src="https://api.smain.cn/pics/pic_def6e004.png" alt="pic_def6e004.png"></p><blockquote><p>介绍完了延时消息，下面进行案例演示，以下是项目流程图：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_02afc096.png" alt="pic_02afc096.png"></p><blockquote><p>这里描述主要流程，涉及三个服务：订单服务、支付服务 和 商品服务。当用户提交订单后，系统将依次完成以下步骤：</p></blockquote><blockquote><ul><li>扣减库存：调用商品服务扣减对应商品的库存。</li><li>创建支付订单：订单服务创建支付订单，并跳转至支付服务。</li><li>支付处理：用户在支付服务中完成支付，支付成功后，支付服务通过消息通知订单服务支付成功。</li><li>消息丢失处理：如果支付服务长时间未向订单服务返回支付成功的消息（可能由于消息丢失），订单服务会通过延迟消息机制检测到异常。</li><li>关闭订单：订单服务将支付订单状态修改为 已关闭，并调用支付服务将支付状态同步为 已取消。</li><li>恢复库存：订单服务调用商品服务，恢复相应的商品库存。</li></ul></blockquote><blockquote><p>这样，通过延迟消息机制和状态回滚，系统能够有效应对消息丢失，确保最终一致性。</p></blockquote><p>改造下单业务，发送延迟消息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5.发送延迟消息，检测订单支付状态</span></span><br><span class="line">rabbitTemplate.convertAndSend(</span><br><span class="line">    MQConstants.DELAY_EXCHANGE_NAME,</span><br><span class="line">    MQConstants.DELAY_ORDER_KEY,</span><br><span class="line">    order.getId(),</span><br><span class="line">    message -&gt; &#123;</span><br><span class="line">        message.getMessageProperties().setDelay(<span class="number">1800000</span>); <span class="comment">// 延时30分钟</span></span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这里将 交换机 和 Routing key 写成了一个常量类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MQConstants</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">DELAY_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;trade.delay.direct&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">DELAY_ORDER_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;trade.delay.order.queue&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">DELAY_ORDER_KEY</span> <span class="operator">=</span> <span class="string">&quot;delay.order.query&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写监听消息，查询支付状态：</p><p><img src="https://api.smain.cn/pics/pic_88be4dac.png" alt="pic_88be4dac.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDelayMessageListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IOrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PayClient payClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = MQConstants.DELAY_ORDER_QUEUE_NAME),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = MQConstants.DELAY_EXCHANGE_NAME, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            key = MQConstants.DELAY_ORDER_KEY</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenOrderDelayMessage</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询订单</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderService.getById(orderId);</span><br><span class="line">        <span class="comment">// 2.检测订单状态，判断是否支付</span></span><br><span class="line">        <span class="keyword">if</span>(order == <span class="literal">null</span> || order.getStatus() != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 不存在或者是已支付</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.未支付，需要查询支付流水状态</span></span><br><span class="line">        <span class="type">PayOrderDTO</span> <span class="variable">payOrder</span> <span class="operator">=</span> payClient.queryPayOrderByBizOrderNo(orderId);</span><br><span class="line">        <span class="comment">// 4.判断是否支付</span></span><br><span class="line">        <span class="keyword">if</span>(payOrder != <span class="literal">null</span> &amp;&amp; payOrder.getStatus() == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="comment">// 4.1.已支付，标记订单状态为已支付</span></span><br><span class="line">            orderService.markOrderPaySuccess(orderId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 4.2.未支付，取消订单，恢复库存</span></span><br><span class="line">            orderService.cancelOrder(orderId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从这个类绑定的交换机不难看出它就是用来处理延时消息后的逻辑的，其中查询支付状态已经实现，我们拿到支付状态后如果已支付就可以直接对订单的状态进行更改，但是如果消息超时了就需要进行回滚操作也就是其中的 cancelOrder 方法，下面就来实现这个方法。</p></blockquote><p>cancelOrder</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancelOrder</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.修改交易订单状态为已关闭</span></span><br><span class="line">    lambdaUpdate()</span><br><span class="line">            .set(Order::getStatus, <span class="number">5</span>)</span><br><span class="line">            .eq(Order::getId, orderId)</span><br><span class="line">            .update();</span><br><span class="line">    <span class="comment">// 2.修改支付状态为已取消</span></span><br><span class="line">    payClient.updatePayOrderStatusByBizOrderNo(orderId, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 3.恢复库存</span></span><br><span class="line">    List&lt;OrderDetail&gt; list = detailService.lambdaQuery().eq(OrderDetail::getOrderId, orderId).list();</span><br><span class="line">    List&lt;OrderDetailDTO&gt; orderDetailDTOS = BeanUtils.copyToList(list, OrderDetailDTO.class);</span><br><span class="line">    itemClient.restoreStock(orderDetailDTOS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中的更新支付状态以及回复库存的接口还需要我们实现</p></blockquote><p>payClient</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;pay-service&quot;, fallbackFactory = PayClientFallback.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PayClient</span> &#123;</span><br><span class="line">    <span class="meta">@PutMapping(&quot;/pay-orders/status/&#123;id&#125;/&#123;status&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updatePayOrderStatusByBizOrderNo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long orderId, <span class="meta">@PathVariable(&quot;status&quot;)</span> Integer status)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>payController</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;修改支付订单状态&quot;)</span></span><br><span class="line"><span class="meta">@PutMapping(&quot;/status/&#123;id&#125;/&#123;status&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updatePayOrderStatusByBizOrderNo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long orderId, <span class="meta">@PathVariable(&quot;status&quot;)</span> Integer status)</span>&#123;</span><br><span class="line">    payOrderService.updateStatusByOrderId(orderId, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>payServiceImpl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateStatusByOrderId</span><span class="params">(Long orderId, Integer status)</span> &#123;</span><br><span class="line">    lambdaUpdate()</span><br><span class="line">            .set(PayOrder::getStatus, status)</span><br><span class="line">            .eq(PayOrder::getBizOrderNo, orderId) <span class="comment">//注意这里第一个参数是拿支付表中的订单id而不是支付id</span></span><br><span class="line">            .update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>itemClient</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;item-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line">    <span class="meta">@PutMapping(&quot;/items/stock/restore&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">restoreStock</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;OrderDetailDTO&gt; orderDetails)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>itemController</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;恢复库存&quot;)</span></span><br><span class="line"><span class="meta">@PutMapping(&quot;/stock/restore&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreStock</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;OrderDetailDTO&gt; orderDetails)</span> &#123;</span><br><span class="line">    itemService.restoreStock(orderDetails);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>itemServiceImpl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreStock</span><span class="params">(List&lt;OrderDetailDTO&gt; orderDetails)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(OrderDetailDTO orderDetail : orderDetails) &#123;</span><br><span class="line">        <span class="comment">// 根据商品id查询商品</span></span><br><span class="line">        <span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> lambdaQuery().eq(Item::getId, orderDetail.getItemId()).one();</span><br><span class="line">        <span class="comment">// 还原库存</span></span><br><span class="line">        lambdaUpdate()</span><br><span class="line">                .set(Item :: getStock, item.getStock() + orderDetail.getNum())</span><br><span class="line">                .eq(Item::getId, orderDetail.getItemId())</span><br><span class="line">                .update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>至此所有功能开发完毕，进行测试看商品数据是否恢复，支付状态是否更新：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_1f74dbeb.png" alt="pic_1f74dbeb.png"></p><p><img src="https://api.smain.cn/pics/pic_8725c95f.png" alt="pic_8725c95f.png"></p><h2 id="5、结语"><a href="#5、结语" class="headerlink" title="5、结语"></a>5、结语</h2><blockquote><p>微服务架构为现代应用提供了更高的灵活性和可扩展性，同时也带来了更多的挑战。在本文中，我们通过实际案例，探讨了服务调用的全过程，分析了同步和异步调用的不同场景，并介绍了如何利用负载均衡、服务注册与发现等关键技术来实现微服务间的高效通信。</p><p>尽管微服务架构能极大提升开发和部署的效率，但在实际应用中，我们仍需面对分布式事务、服务治理等问题。未来的学习中，深入理解这些问题并探索解决方案，将帮助我们构建更可靠、更高效的分布式系统。</p><p>希望这篇文章能为你在微服务的学习和实践上提供一些思路，也期待我们在这个领域不断积累经验，迎接更多的挑战。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux（Centos7）安装docker、mysql踩坑总结</title>
      <link href="/2025/01/12/Linux%EF%BC%88Centos7%EF%BC%89%E5%AE%89%E8%A3%85docker%E3%80%81mysql%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93/"/>
      <url>/2025/01/12/Linux%EF%BC%88Centos7%EF%BC%89%E5%AE%89%E8%A3%85docker%E3%80%81mysql%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要是记录了在 CentOS 7 上安装 Docker 和 MySQL 时遇到的一些问题，主要是由于镜像源未配置正确，导致无法顺利下载所需的依赖包。下面将介绍在安装过程中遇到的困难，并分享如何通过配置合适的镜像源来解决这些问题，从而顺利完成 Docker 和 MySQL 的安装，希望能够帮到有需要的人。</p></blockquote><h4 id="一、安装准备"><a href="#一、安装准备" class="headerlink" title="一、安装准备"></a>一、安装准备</h4><blockquote><p>系统版本：CentOS 7</p><p>先安装 yum：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><blockquote><p>执行之前先配置一下镜像源，输入以下命令进入配置文件：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vim /etc/yum.repos.d/CentOS-Base.repo</span><br></pre></td></tr></table></figure><blockquote><p>再将 mirrorlist 注释掉然后将 baseurl 改为阿里云镜像，然后保存退出</p></blockquote><p><img src="https://api.smain.cn/pics/pic_8fcb7204.png" alt="pic_8fcb7204.png"></p><blockquote><p>一定要将 mirrorlist 注释掉！不然还是会直接访问官方源导致下载失败！</p></blockquote><blockquote><p>输入下面的命令检验是否安装成功：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_22eea1b9.png" alt="pic_22eea1b9.png"></p><blockquote><p>当然不排除网络问题，可以先用 ping 命令测试一下网络是否连通：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_869db52c.png" alt="pic_869db52c.png"></p><blockquote><p>只要网络连通，并且配置文件修改无误就肯定能安装成功。</p></blockquote><h4 id="二、安装-Docker"><a href="#二、安装-Docker" class="headerlink" title="二、安装 Docker"></a>二、安装 Docker</h4><blockquote><p>执行下列命令安装：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure><blockquote><p>下面是 Docker 的一些常用命令：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 启动Docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 停止Docker</span><br><span class="line">systemctl stop docker</span><br><span class="line"></span><br><span class="line"># 重启</span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line"># 设置开机自启</span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line"># 执行docker ps命令，如果不报错，说明安装启动成功</span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"># 列出本地 Docker 主机上已经下载或构建的所有镜像</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><blockquote><p>可以看到刚刚安装好 docker 后是没有镜像的：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_e644b8d0.png" alt="pic_e644b8d0.png"></p><h4 id="三、安装-MySQL"><a href="#三、安装-MySQL" class="headerlink" title="三、安装 MySQL"></a>三、安装 MySQL</h4><blockquote><p>现在要使用 docker 安装 mysql 镜像，注意如果之前有在虚拟机上安装过 mysql 要先停掉，不然会端口冲突：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">systemctl stop mysqld</span><br></pre></td></tr></table></figure><blockquote><p>如果直接 docker pull mysql，多半会报错：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Error response from daemon: Get <span class="string">&quot;https://registry-1.docker.io/v2/&quot;</span>: net/http: request canceled <span class="keyword">while</span> waiting <span class="keyword">for</span> <span class="title function_">connection</span> <span class="params">(Client.Timeout exceeded <span class="keyword">while</span> awaiting headers)</span></span><br></pre></td></tr></table></figure><blockquote><p>所以还是先配置镜像，值得一提的是在写这篇文章的时候阿里云的镜像加速已经停用了，所以得找别的镜像。</p></blockquote><blockquote><p>创建一个 docker 的配置文件，然后设置镜像源：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 创建目录</span><br><span class="line">mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line">#创建文件</span><br><span class="line">touch daemon.json</span><br><span class="line"></span><br><span class="line">#进入编辑</span><br><span class="line">vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://gallery.ecr.aws/&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://gitverse.ru/docs/artifactory/gitverse-registry/&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://docker.lmirror.top&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://atomhub.openatom.cn/&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这几个镜像目前测试是有效的，然后再 docker pull mysql</p><p>可以看到很快就下好了，再使用 docker images：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_dd193e67.png" alt="pic_dd193e67.png"></p><blockquote><p>成功拉取！最后下载 mysql：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p <span class="number">3306</span>:<span class="number">3306</span> \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=<span class="number">123</span> \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><blockquote><p>其中设置的用户名是 root ，密码是 123，如有需要自行更改。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_8fda741d.png" alt="pic_8fda741d.png"></p><blockquote><p>安装成功！来测试一下能否连接成功：</p><p>在 navicat 中新建连接，其中 Host 填你自己的虚拟机 IP 地址</p><p>使用 ifconfig 即可查看</p></blockquote><p><img src="https://api.smain.cn/pics/pic_c0b322a5.png" alt="pic_c0b322a5.png"></p><p><img src="https://api.smain.cn/pics/pic_bbd51289.png" alt="pic_bbd51289.png"></p><h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><blockquote><p>最后有几点需要注意：</p><p>1、重新启动虚拟机后需要再次停用原来的 mysql 防止端口冲突</p><p>2、开启 dokcer 后 mysql 并没有一并被开启，需要输入 dokcer start mysql 开启</p><p>3、如果发现数据库连接不上了可以考虑关闭虚拟机的防火墙</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 查看防火墙状态</span><br><span class="line">firewall-cmd --state</span><br><span class="line"></span><br><span class="line"># 关闭防火墙</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Python与Fiddler实现图书馆座位自动预约：实战经验分享</title>
      <link href="/2025/01/04/%E7%94%A8Python%E4%B8%8EFiddler%E5%AE%9E%E7%8E%B0%E5%9B%BE%E4%B9%A6%E9%A6%86%E5%BA%A7%E4%BD%8D%E8%87%AA%E5%8A%A8%E9%A2%84%E7%BA%A6%EF%BC%9A%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
      <url>/2025/01/04/%E7%94%A8Python%E4%B8%8EFiddler%E5%AE%9E%E7%8E%B0%E5%9B%BE%E4%B9%A6%E9%A6%86%E5%BA%A7%E4%BD%8D%E8%87%AA%E5%8A%A8%E9%A2%84%E7%BA%A6%EF%BC%9A%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：</p><p>期末周图书馆座位总是供不应求，每天早上七点开始预约，不到十分钟位置就被抢光。对于我们这些爱睡懒觉的人来说，简直是噩梦！而恰好这学期我正在学习计算机网络课程，何不趁机动手写一个自动预约程序，解决这个问题呢？于是这篇博客应运而生。</p><p>免责声明：</p><p>本博客仅供计算机网络爱好者学习交流使用，请勿用于非法用途！</p></blockquote><p>目录</p><p><a href="#%E4%B8%80%E3%80%81%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90">一、需求分析</a></p><p><a href="#%E4%BA%8C%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%87%86%E5%A4%87">二、开发工具准备</a></p><p><a href="#%E4%B8%89%E3%80%81%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0">三、功能实现</a></p><h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><blockquote><p>我们的目标很明确，那就是使用自动化脚本实现图书馆座位的预约。我所在的学校由于只能通过微信公众号来进行预约，所以相较于能够直接在网站上预约的学校来说，数据抓包相对复杂一点，所以才会用到 fidder，不然直接浏览器 F12 就可以直接看数据包了。</p></blockquote><p>让我们来分析一下要干些什么事情：</p><blockquote><ol><li>使用电脑登陆微信，进入公众号模拟预约</li><li>使用 fidder 对刚才的操作进行抓包</li><li>对数据包经行分析，提取出对应的用户登录数据以及座位预约信息</li><li>使用 Python 的 requests 库模拟用户向图书馆服务器发送预约请求</li><li>编辑定时器固定在早上 7 点执行程序</li></ol></blockquote><h3 id="二、开发工具准备"><a href="#二、开发工具准备" class="headerlink" title="二、开发工具准备"></a>二、开发工具准备</h3><blockquote><p>明确了需求，下面来准备开发工具。</p></blockquote><h4 id="1、首先先安装好-Python"><a href="#1、首先先安装好-Python" class="headerlink" title="1、首先先安装好 Python"></a>1、首先先安装好 Python</h4><p><a href="http://www.python.org/download/">http://www.python.org/download/</a></p><p>安装步骤其他博客已经讲的非常详细了，这里就不多说了</p><h4 id="2、然后介绍一下-Python-requests-库："><a href="#2、然后介绍一下-Python-requests-库：" class="headerlink" title="2、然后介绍一下 Python requests 库："></a>2、然后介绍一下 Python requests 库：</h4><blockquote><p>requests 是一个非常流行且易于使用的 Python 库，用于发送 HTTP 请求并与 Web 服务器进行交互。它简化了 HTTP 请求的工作流程，提供了简单的接口来进行常见的 HTTP 操作，例如 GET、POST、PUT、DELETE 等。</p><p>这次主要是用到了 post 函数向服务器发送预约请求，将 url、headers、data 这三个数据解析好之后就通过 requests.post 发送。</p></blockquote><p>我这里用的是 VScode 进行开发，只需要在终端输入如下命令，即可完成 requests 库的安装：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install requests</span><br></pre></td></tr></table></figure><p>然后在命令行可通过导入 import 库来测试 requests 是否安装成功：</p><p><img src="https://api.smain.cn/pics/pic_1f98df1b.png" alt="pic_1f98df1b.png"></p><p>这样就算是装好了</p><h4 id="3、下面介绍这次的关键抓包工具-fidder"><a href="#3、下面介绍这次的关键抓包工具-fidder" class="headerlink" title="3、下面介绍这次的关键抓包工具 fidder"></a>3、下面介绍这次的关键抓包工具 fidder</h4><blockquote><p>Fiddler 是最常用的 Web 调试工具之一。对于开发来说，前端可以通过 Fiddler 代理来调试 JS、CSS、HTML 样式。后端可以通过 Fiddler 查看请求和相应，定位问题。对于测试来说，可以通过抓包方式修改前端请求参数和模拟后端返回，快速定位缺陷。总之，不管是开发还是测试，Fiddler 都是一款工作中不可或缺的辅助利器。</p></blockquote><p>官网：<a href="https://www.telerik.com/fiddler">https://www.telerik.com/fiddler</a></p><p>安装过程就是无脑下一步就行了，装好后点击 <code>Fiddler.exe</code> 运行：</p><p><img src="https://api.smain.cn/pics/pic_704efb9d.png" alt="pic_704efb9d.png"></p><blockquote><p>看上去有点复杂，不过不要慌，我们只需要会用基本的功能就可以了</p></blockquote><p>下面来配置 fidder：</p><blockquote><p>启用 HTTPS 解密</p><ol><li><p>在 Fiddler 菜单中，点击 <code>Tools &gt; Options</code>。</p></li><li><p>选择 <code>HTTPS</code> 标签页，勾选：</p><ul><li><code>Capture HTTPS CONNECTs</code></li><li><code>Decrypt HTTPS traffic</code></li></ul></li><li><p>点击 <code>Actions &gt; Trust Root Certificate</code>，安装 Fiddler 的证书。</p></li></ol></blockquote><p><img src="https://api.smain.cn/pics/pic_464cb2c6.png" alt="pic_464cb2c6.png"></p><p><img src="https://api.smain.cn/pics/pic_25ea9037.png" alt="pic_25ea9037.png"></p><blockquote><p>设置抓包范围</p><ol><li>选择 <code>Tools &gt; Options &gt; Connections</code>。</li><li>确保 <code>Allow remote computers to connect</code> 已勾选。</li><li>记下 Fiddler 的监听端口（默认是 8888）。</li></ol></blockquote><p><img src="https://api.smain.cn/pics/pic_dfdc7fd3.png" alt="pic_dfdc7fd3.png"></p><blockquote><p>配置系统代理</p><p>抓取电脑端微信的流量，需要将微信的数据流经 Fiddler。</p><p>在 Windows 系统设置代理</p><ol><li><p>打开设置 -&gt; 网络和 Internet -&gt; 代理</p></li><li><p>启用 使用代理服务器，并填写代理地址</p></li></ol><p>地址： 127.0.0.1</p><p>端口： 8888（与 fidder 配置一致）</p></blockquote><p><img src="https://api.smain.cn/pics/pic_26713077.png" alt="pic_26713077.png"></p><blockquote><p>到这里，fidder 就已经能够对微信的数据流进行监听了！</p></blockquote><h3 id="三、功能实现"><a href="#三、功能实现" class="headerlink" title="三、功能实现"></a>三、功能实现</h3><blockquote><p>现在工具都准备好了，我们马上开干！</p></blockquote><h4 id="1、执行预约流程并分析抓包数据"><a href="#1、执行预约流程并分析抓包数据" class="headerlink" title="1、执行预约流程并分析抓包数据"></a>1、执行预约流程并分析抓包数据</h4><blockquote><p>（1）打开微信客户端：</p><p>检查 fidder 中数据流是否检查到微信。</p><p>（2）进入预约界面：</p><p>打开图书馆预约系统，执行预约操作（选择座位、时间）然后提交表单。</p><p>（3）监控 fidder：</p><p>点击左侧的对应网络请求</p></blockquote><p><img src="https://api.smain.cn/pics/pic_c60379ff.png" alt="pic_c60379ff.png"></p><blockquote><p>然后点击 Inspectors 查看数据包，再点击 Row 将整个请求显示为纯文本：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_b1b01776.png" alt="pic_b1b01776.png"></p><blockquote><p>然后查看具体响应内容：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_cccc60d1.png" alt="pic_cccc60d1.png"></p><blockquote><p>以下内容需要重点关注：</p><ul><li>目标 URL</li><li>Cookies</li></ul></blockquote><blockquote><p>其中 URL 指明了目标访问地址 ，Cookies 中包含了你的用户身份信息，以及你的选座信息。</p></blockquote><h4 id="2、模拟请求"><a href="#2、模拟请求" class="headerlink" title="2、模拟请求"></a>2、模拟请求</h4><blockquote><p>新建一个.py 文件，引入 requests 然后将数据复制过来</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># URL 地址</span></span><br><span class="line">url = <span class="string">&quot; &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求头，从 Raw 中提取</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;Connection&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;X-Requested-With&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;Origin&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;Sec-Fetch-Site&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;Sec-Fetch-Mode&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;Sec-Fetch-Dest&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;Referer&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;Cookie&quot;</span>: <span class="string">&quot; &quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 表单数据模板</span></span><br><span class="line">data_template = &#123;</span><br><span class="line">    <span class="string">&quot;code&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;data_type&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;seatdate&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;seatno&quot;</span>：<span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;seatname&quot;</span>:<span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;datetime&quot;</span>: <span class="string">&quot; &quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>发送 POST 请求</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response = requests.post(url, headers=headers, data=data)</span><br></pre></td></tr></table></figure><blockquote><p>然后运行程序，如果看到输出状态码为 200，就表明成功与服务器交换数据，然后根据返回信息查看是否预约成功。这里推荐使用日志记录一下，这样调试起来也更方便。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置日志记录</span></span><br><span class="line">logging.basicConfig(</span><br><span class="line">    filename=<span class="string">&quot; &quot;</span>,  <span class="comment"># 设置日志文件路径</span></span><br><span class="line">    level=logging.INFO,  <span class="comment"># 日志等级</span></span><br><span class="line">    <span class="built_in">format</span>=<span class="string">&quot;%(asctime)s - %(levelname)s - %(message)s&quot;</span>,  <span class="comment"># 日志格式</span></span><br><span class="line">    filemode=<span class="string">&#x27;a&#x27;</span>,  <span class="comment"># 追加写入模式</span></span><br><span class="line">    encoding=<span class="string">&#x27;utf-8&#x27;</span>  <span class="comment"># 设置编码格式为utf-8</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录响应信息</span></span><br><span class="line">    logging.info(<span class="string">f&quot;状态码: <span class="subst">&#123;response.status_code&#125;</span>&quot;</span>)</span><br><span class="line">    logging.info(<span class="string">f&quot;响应内容: <span class="subst">&#123;response.text&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>如果响应数据没问题，那就成功了！下一步就是设置一个定时任务让这个程序在每天早上 7 点准时执行。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_57297dcf.png" alt="pic_57297dcf.png"></p><blockquote><p>打开任务计划程序，创建定时任务</p></blockquote><p><img src="https://api.smain.cn/pics/pic_685cedde.png" alt="pic_685cedde.png"></p><p><img src="https://api.smain.cn/pics/pic_8824802d.png" alt="pic_8824802d.png"></p><p><img src="https://api.smain.cn/pics/pic_e8353aa9.png" alt="pic_e8353aa9.png"></p><p><img src="https://api.smain.cn/pics/pic_cf127d9c.png" alt="pic_cf127d9c.png"></p><p><img src="https://api.smain.cn/pics/pic_054c03d2.png" alt="pic_054c03d2.png"></p><blockquote><p>创建好后直接执行测试一下，然后取日志里看是否正常，如果一切正常，那就大功告成了！</p></blockquote><p><img src="https://api.smain.cn/pics/pic_2ae276db.png" alt="pic_2ae276db.png"></p><blockquote><p>最后再次声明一下，如果没有预约成功，请你在调试的时候一定要检查清楚代码的逻辑后再运行！不要短时间内多次访问服务器！否则有可能被检测到然后封禁！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> fiddler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于若依框架的SpringBoot管理系统学习</title>
      <link href="/2024/10/24/%E5%9F%BA%E4%BA%8E%E8%8B%A5%E4%BE%9D%E6%A1%86%E6%9E%B6%E7%9A%84SpringBoot%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/10/24/%E5%9F%BA%E4%BA%8E%E8%8B%A5%E4%BE%9D%E6%A1%86%E6%9E%B6%E7%9A%84SpringBoot%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote><p>在现代企业开发中，快速搭建高效、稳定的管理系统是一个常见的需求。而若依框架作为一个基于 SpringBoot 的开源管理系统框架，凭借其模块化设计、便捷的代码生成工具以及优秀的前端整合方案，成为了许多开发者的首选。对于初学者来说，若依框架不仅是学习 SpringBoot 开发的良好切入点，也是深入理解后台管理系统开发流程的最佳实践平台。</p><p>本文将结合学习若依框架的实际过程，从框架搭建到核心功能实现，对其中的重要知识点和开发技巧进行深入解析，帮助读者快速上手并掌握若依框架的使用技巧，同时为开发自己的管理系统打下坚实的基础。</p></blockquote><h4 id="一、什么是若依？"><a href="#一、什么是若依？" class="headerlink" title="一、什么是若依？"></a>一、什么是若依？</h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h5><blockquote><p>若依框架（RuoYi）是一个基于 SpringBoot 和 Vue 的快速开发平台，常用于构建后台管理系统。它采用前后端分离的架构，前端使用 Vue.js，后端使用 SpringBoot，数据库则支持多种类型（如 MySQL、MariaDB 等）。框架集成了一些主流的开源组件，如 MyBatis、Redis、Druid、Swagger 等，使得开发人员能够快速搭建和扩展项目功能。</p></blockquote><blockquote><p>gitee 地址：</p><p>后端 <a href="https://gitee.com/y_project/RuoYi">https://gitee.com/y_project&#x2F;RuoYi</a></p><p>前端 <a href="https://gitee.com/y_project/RuoYi-Vue">https://gitee.com/y_project&#x2F;RuoYi-Vue</a></p></blockquote><blockquote><p>技术版本：</p><ul><li>JDK &gt;&#x3D; 1.8</li><li>MySQL &gt;&#x3D; 5.7</li><li>Maven &gt;&#x3D; 3.0</li><li>Node &gt;&#x3D; 12</li><li>Redis &gt;&#x3D; 3</li></ul></blockquote><h5 id="2-若依框架的特点"><a href="#2-若依框架的特点" class="headerlink" title="2.若依框架的特点"></a>2.若依框架的特点</h5><blockquote><ul><li>模块化设计：内置了用户管理、角色权限、菜单管理、操作日志、定时任务等常见的管理系统功能模块，可以快速搭建企业级应用。</li><li>前后端分离：前端与后端独立开发和部署，提高了开发效率和用户体验。</li><li>丰富的技术栈集成：集成了多种常用的技术和工具（如 MyBatis 做数据持久化，Redis 做缓存，Druid 作为数据库连接池），简化了开发过程。</li><li>高扩展性：代码结构清晰，支持二次开发，可以根据业务需求进行自定义扩展。</li></ul></blockquote><h5 id="3-若依框架的目录结构"><a href="#3-若依框架的目录结构" class="headerlink" title="3.若依框架的目录结构"></a>3.若依框架的目录结构</h5><blockquote><p>若依的后端项目主要分为六个模块，他们之间的依赖关系如下图所示：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_59f382bd.png" alt="pic_59f382bd.png"></p><p>下面我们来分析一下每个模块的具体功能</p><p><img src="https://api.smain.cn/pics/pic_e9c40141.png" alt="pic_e9c40141.png"></p><p><img src="https://api.smain.cn/pics/pic_1c2520b9.png" alt="pic_1c2520b9.png"></p><p><img src="https://api.smain.cn/pics/pic_1e9d8b33.png" alt="pic_1e9d8b33.png"></p><p><img src="https://api.smain.cn/pics/pic_aa8ccf3b.png" alt="pic_aa8ccf3b.png"></p><blockquote><p>从上面的几张图我们可以看出若依的主要框架包括 admin、common、framework 和 system，至于 quartz 和 generator 它们并不是必须的，但是有了它们，可以大大加快我们程序的开发速度，后面我们会讲到如何使用。</p></blockquote><p>若依的配置文件主要放在-admin 包中</p><p><img src="https://api.smain.cn/pics/pic_16f83402.png" alt="pic_16f83402.png"></p><p>接下来是项目相关的数据库表</p><p><img src="https://api.smain.cn/pics/pic_3d67c75b.png" alt="pic_3d67c75b.png"></p><p>然后让我们来看看前端的项目结构</p><blockquote><p>这张图完整了列出了前端项目的框架，但是如果你像我一样重心放在后端开发，那其实只需要了解其中一部份模块的功能就行了，下面这张图列出了后端人员经常需要用到的几个模块。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_39357e97.png" alt="pic_39357e97.png"></p><p>下面们来分析一下若依后端的具体代码</p><blockquote><p>首先从 Controller 开始，若依框架中的 Controller 都继承了 BaseController 类，实现了基本的数据分页展示功能、用户登录相关方法、以及请求成功或者失败后的相关处理。可以说，若依的这个 BaseController 类基本上实现了业务开发所要用到的大多数常用功能。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_8f67fd18.png" alt="pic_8f67fd18.png"></p><blockquote><p>然后是我们比较关心的返回对象的封装，若依将返回对象分为了两类，一类是分页查询返回对象，另一类是增删改查返回对象。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_9d46515e.png" alt="pic_9d46515e.png"></p><p><img src="https://api.smain.cn/pics/pic_b2b81c37.png" alt="pic_b2b81c37.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;@ss.hasPermi(&#x27;manage:partner:list&#x27;)&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> TableDataInfo <span class="title function_">list</span><span class="params">(Partner partner)</span></span><br><span class="line">    &#123;</span><br><span class="line">        startPage();</span><br><span class="line">        List&lt;PartnerVo&gt; list = partnerService.selectPartnerVOList(partner);</span><br><span class="line">        <span class="keyword">return</span> getDataTable(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/captchaImage&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> AjaxResult <span class="title function_">getCode</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">AjaxResult</span> <span class="variable">ajax</span> <span class="operator">=</span> AjaxResult.success();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">captchaEnabled</span> <span class="operator">=</span> configService.selectCaptchaEnabled();</span><br><span class="line">        ajax.put(<span class="string">&quot;captchaEnabled&quot;</span>, captchaEnabled);</span><br><span class="line">        <span class="keyword">if</span> (!captchaEnabled)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ajax;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><blockquote><p>值得一提的是@PreAuthorize 注解是 Spring Security 的一个权限认证注解，它与前端联调之后能够实现权限控制访问。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;@ss.hasPermi(&#x27;manage:partner:edit&#x27;)&quot;)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;el-button link type=<span class="string">&quot;primary&quot;</span> <span class="meta">@click</span>=<span class="string">&quot;resetPassword(scope.row)&quot;</span> v-hasPermi=<span class="string">&quot;[&#x27;manage:partner:edit&#x27;]&quot;</span>&gt;重置密码&lt;/el-button&gt;</span><br></pre></td></tr></table></figure><p><img src="https://api.smain.cn/pics/pic_c06ad374.png" alt="pic_c06ad374.png"></p><p>前后端交互流程：</p><p><img src="https://api.smain.cn/pics/pic_e4586998.png" alt="pic_e4586998.png"></p><p><img src="https://api.smain.cn/pics/pic_471e64aa.png" alt="pic_471e64aa.png"></p><h4 id="二、若依框架的项目搭建"><a href="#二、若依框架的项目搭建" class="headerlink" title="二、若依框架的项目搭建"></a>二、若依框架的项目搭建</h4><h5 id="1-后端项目初始化配置"><a href="#1-后端项目初始化配置" class="headerlink" title="1.后端项目初始化配置"></a>1.后端项目初始化配置</h5><h6 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h6><blockquote><p>将后端代码克隆的本地后会有两个 sql 脚本，先创建好你的数据库然后修改数据库连接配置</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    druid:</span><br><span class="line">      url: jdbc:mysql:<span class="comment">//localhost:3306/ruoyi?</span></span><br><span class="line">      useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf8&amp;serverTimezone=UTC</span><br><span class="line">      username: your_db_username</span><br><span class="line">      password: your_db_password</span><br></pre></td></tr></table></figure><blockquote><p>ruoyi 是数据库的名字，然后执行下面的 sql 脚本就行了。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_3c915a97.png" alt="pic_3c915a97.png"></p><h6 id="配置-Redis-缓存"><a href="#配置-Redis-缓存" class="headerlink" title="配置 Redis 缓存"></a>配置 Redis 缓存</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: <span class="number">6379</span></span><br><span class="line">    password: your_redis_password</span><br></pre></td></tr></table></figure><blockquote><p>注意：启动项目之前记得一定要把 Redis 打开，不然会报错。</p></blockquote><h6 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h6><blockquote><p>若依框架的依赖管理主要使用 Maven，<code>pom.xml</code>文件配置了各种依赖，包括 Spring Boot、MyBatis、Redis、Swagger 等。以下是主要依赖的说明：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.0</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h5 id="2-启动项目"><a href="#2-启动项目" class="headerlink" title="2.启动项目"></a>2.启动项目</h5><blockquote><p>启动后端项目：在<code>ruoyi-admin</code>目录下执行<code>RuoYiApplication</code>类中的<code>main</code>方法，启动 SpringBoot 后端服务。</p><p>启动前端项目：在<code>ruoyi-ui</code>目录下，执行以下命令安装依赖并启动前端服务：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h5 id="3-界面展示"><a href="#3-界面展示" class="headerlink" title="3.界面展示"></a>3.界面展示</h5><blockquote><p>成功启动后页面会自动跳转到如下登录界面，登录密码默认是 admin123，若依的密码使用了 MD5 加密存储，所以在数据库里面是看不到的。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_44fe88e3.png" alt="pic_44fe88e3.png"></p><h5 id="4-功能详讲"><a href="#4-功能详讲" class="headerlink" title="4.功能详讲"></a>4.功能详讲</h5><blockquote><p>若依框架的菜单功能是后台管理系统的核心部分，涵盖了系统管理、监控、工具等多种模块。以下是若依系统默认的菜单结构和功能介绍：</p><h6 id="1-系统管理"><a href="#1-系统管理" class="headerlink" title="1. 系统管理"></a>1. 系统管理</h6><p>主要用于管理系统中的基础设置和权限控制，包括用户、角色、菜单等内容。主要功能如下：</p><ul><li>用户管理<br>管理系统中的用户信息，包括新增、编辑、删除用户，以及为用户分配角色和重置密码等操作。</li><li>角色管理<br>定义系统中的角色，并为角色分配菜单权限。可以设置角色的权限范围，控制其可访问的菜单项。</li><li>菜单管理<br>用于配置系统的菜单显示和访问权限，支持添加、编辑、删除菜单项。可以设置菜单的类型（目录、菜单、按钮）、排序、图标等信息。</li><li>部门管理<br>维护系统的组织架构，支持树形结构显示部门信息。可以新增、编辑、删除部门，以及查看部门成员。</li><li>岗位管理<br>定义系统中的岗位信息，用于关联用户岗位。可以新增、编辑、删除岗位。</li><li>字典管理<br>管理系统中的字典数据，如状态、性别等常用数据项。可以为每个字典项设置标签和值。</li><li>参数设置<br>用于管理系统中的配置参数，可以动态修改参数值而无需重启服务。</li><li>通知公告<br>发布和管理系统内的公告信息，支持查看公告的详细内容。</li></ul><h6 id="2-系统监控"><a href="#2-系统监控" class="headerlink" title="2. 系统监控"></a>2. 系统监控</h6><p>主要用于监控系统的运行状态、日志记录等内容，帮助运维人员管理和排查系统问题。主要功能包括：</p><ul><li>在线用户<br>显示当前在线的用户列表，可以查看用户登录信息和强制下线。</li><li>定时任务<br>管理系统中的定时任务（调度任务），支持任务的新增、编辑、删除，以及手动执行和暂停任务。若依默认使用 Quartz 作为定时任务调度器。</li><li>操作日志<br>记录用户的操作行为，如新增、编辑、删除等操作，便于审计和问题追踪。</li><li>登录日志<br>记录用户的登录历史，包括登录时间、IP 地址、登录状态等信息。</li><li>系统日志<br>显示系统的运行日志，便于运维人员查看和分析问题。</li></ul><h6 id="3-系统工具"><a href="#3-系统工具" class="headerlink" title="3. 系统工具"></a>3. 系统工具</h6><p>提供一些开发和运维相关的工具，帮助开发人员和运维人员提高工作效率。主要功能包括：</p><ul><li>代码生成<br>根据数据库表结构自动生成基础的代码模板，包括 Controller、Service、Mapper、Entity、Vue 页面等，大幅提高开发效率。支持自定义生成策略。</li><li>系统接口<br>提供系统 API 的在线文档，基于 Swagger 生成，支持在线测试和接口文档查看。</li><li>表单构建<br>可视化创建表单，支持生成 Vue 表单页面，简化前端开发工作。</li></ul></blockquote><p><img src="https://api.smain.cn/pics/pic_0ed0d635.png" alt="pic_0ed0d635.png"></p><h5 id="5-若依的代码生成器功能"><a href="#5-若依的代码生成器功能" class="headerlink" title="5.若依的代码生成器功能"></a>5.若依的代码生成器功能</h5><blockquote><p>这里就用到了若依的 generator 模块，若依框架的<code>generator</code>模块是一个代码生成器模块，用于自动生成基础的 CRUD 代码和页面模板。这个模块极大地提高了开发效率，尤其是在开发后台管理系统时，减少了重复性的工作。下面是对<code>generator</code>模块的详细讲解：</p></blockquote><h6 id="1-generator模块的主要功能"><a href="#1-generator模块的主要功能" class="headerlink" title="1. generator模块的主要功能"></a>1. <code>generator</code>模块的主要功能</h6><blockquote><ul><li>根据数据库表结构生成代码：可以通过解析数据库表结构自动生成对应的 Java 代码和 Vue 前端代码，包括 Controller、Service、Mapper、Entity（实体类）以及前端的页面（如列表页、表单页）。</li><li>支持自定义模板：可以根据需求自定义代码生成的模板，灵活控制生成代码的风格和内容。</li><li>可配置性强：支持根据生成选项定制生成的代码，例如是否生成分页查询、是否生成插入、删除、更新方法等。</li><li>大幅减少重复开发工作量：生成的代码可以作为基础模板，开发人员只需根据业务需求做个性化调整即可。</li></ul></blockquote><h6 id="2-generator模块的使用步骤"><a href="#2-generator模块的使用步骤" class="headerlink" title="2. generator模块的使用步骤"></a>2. <code>generator</code>模块的使用步骤</h6><blockquote><h6 id="2-1-进入代码生成器界面"><a href="#2-1-进入代码生成器界面" class="headerlink" title="2.1 进入代码生成器界面"></a>2.1 进入代码生成器界面</h6><ul><li>在后台管理系统中，点击左侧菜单的“系统工具” -&gt; “代码生成”即可进入代码生成器的管理界面。</li><li>该界面显示了所有从数据库中读取的表信息，包括表名、表描述、创建时间等</li></ul></blockquote><h6 id=""><a href="#" class="headerlink" title=""></a><img src="https://api.smain.cn/pics/pic_33165d4b.png" alt="pic_33165d4b.png"></h6><blockquote><h6 id="2-2-配置生成参数"><a href="#2-2-配置生成参数" class="headerlink" title="2.2 配置生成参数"></a>2.2 配置生成参数</h6><p>选择需要生成代码的数据库表后，点击“生成配置”按钮进入配置页面，可以对生成的代码进行一些参数配置：</p><ul><li>生成模块名：可以指定代码所属的模块名称。</li><li>生成包路径：用于指定生成的 Java 代码的包路径。</li><li>生成模板：用于指定表的类型，分别有单表、树表和主子表。</li><li>上级菜单：分配到指定菜单下。</li></ul></blockquote><p><img src="https://api.smain.cn/pics/pic_9ae66709.png" alt="pic_9ae66709.png"></p><blockquote><h6 id="2-3-生成代码"><a href="#2-3-生成代码" class="headerlink" title="2.3 生成代码"></a>2.3 生成代码</h6><ul><li>配置完成后，点击“生成代码”按钮，系统会根据配置自动生成对应的 Java 代码和 Vue 前端代码。</li><li>生成的代码会自动打包成一个压缩文件，包含了后端和前端的代码模板，下载后可以解压并将代码复制到项目中进行个性化修改。</li><li>能够对生成的代码进行预览。</li></ul></blockquote><p><img src="https://api.smain.cn/pics/pic_8d7736e5.png" alt="pic_8d7736e5.png"></p><h6 id="3-生成的代码结构"><a href="#3-生成的代码结构" class="headerlink" title="3. 生成的代码结构"></a>3. 生成的代码结构</h6><blockquote><p>生成的代码分为后端代码和前端代码，具体结构如下：</p><h6 id="3-1-后端代码"><a href="#3-1-后端代码" class="headerlink" title="3.1 后端代码"></a>3.1 后端代码</h6><ul><li>Controller 层：负责处理 HTTP 请求，将请求分发给 Service 层，并将响应结果返回给前端。生成的 Controller 代码包含了基本的 CRUD 操作。</li><li>Service 层：负责业务逻辑的处理。生成的 Service 代码通常包含接口和实现类。</li><li>Mapper 层：MyBatis 的 Mapper 接口，用于执行数据库操作。生成的 Mapper 包含基本的增删改查方法。</li><li>Entity 类：表示数据库表的实体类，与表的结构对应。</li><li>Mapper XML：MyBatis 的 SQL 映射文件，包含了 CRUD 操作的 SQL 语句。</li></ul><h6 id="3-2-前端代码"><a href="#3-2-前端代码" class="headerlink" title="3.2 前端代码"></a>3.2 前端代码</h6><ul><li>列表页面（<code>xxx.vue</code>）：用于显示数据列表，支持分页、查询、增删改等操作。</li><li>新增&#x2F;编辑页面：用于添加和修改数据的表单界面。</li><li>前端接口文件（<code>api/xxx.js</code>）：定义了前端对后端的请求方法，如获取列表数据、添加、删除等操作。</li></ul></blockquote><h6 id="4-代码生成器的自定义"><a href="#4-代码生成器的自定义" class="headerlink" title="4. 代码生成器的自定义"></a>4. 代码生成器的自定义</h6><blockquote><p>若依的<code>generator</code>模块支持自定义模板和生成逻辑，满足不同项目的定制化需求：</p><h6 id="4-1-自定义代码生成模板"><a href="#4-1-自定义代码生成模板" class="headerlink" title="4.1 自定义代码生成模板"></a>4.1 自定义代码生成模板</h6><ul><li>若依的代码生成器使用 Freemarker 模板引擎，所有的生成模板都存放在<code>resources/vm</code>目录下。</li><li>可以根据项目的规范和需求，修改默认模板或者添加新的模板来定制生成的代码格式。</li></ul><h6 id="4-2-自定义生成策略"><a href="#4-2-自定义生成策略" class="headerlink" title="4.2 自定义生成策略"></a>4.2 自定义生成策略</h6><ul><li>可以通过修改代码生成器的实现逻辑，改变代码生成的规则。例如，可以在生成时自动添加业务逻辑或增加额外的注释信息。</li></ul></blockquote><h6 id="5-常见的使用场景"><a href="#5-常见的使用场景" class="headerlink" title="5. 常见的使用场景"></a>5. 常见的使用场景</h6><blockquote><ul><li>快速构建 CRUD 模块：对于后台管理系统，CRUD 模块是常见需求，代码生成器可以大幅减少重复的 CRUD 开发工作。</li><li>原型开发：在项目初期快速生成系统的原型，帮助团队进行功能验证和需求讨论。</li><li>代码模板统一：通过定制模板，可以使项目中的代码风格和规范统一，提高代码的可维护性。</li></ul></blockquote><h4 id="三、自定应化若以框架"><a href="#三、自定应化若以框架" class="headerlink" title="三、自定应化若以框架"></a>三、自定应化若以框架</h4><blockquote><p>前言：这部分内容我将会根据实际业务需求来改造若依框架，内容参考 B 站黑马若依“帝可得”项目教程，对若依原理感兴趣的可以去看一下原视频，个人感觉讲的还是比较清楚的。</p></blockquote><h6 id="1-构建基本框架"><a href="#1-构建基本框架" class="headerlink" title="1.构建基本框架"></a>1.构建基本框架</h6><blockquote><p>首先让我们来创建三张表，下面是建表语句：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `tb_region` (</span><br><span class="line">  `id` INT AUTO_INCREMENT COMMENT <span class="string">&#x27;主键id&#x27;</span> PRIMARY KEY,</span><br><span class="line">  `region_name` VARCHAR(<span class="number">255</span>) NOT NULL COMMENT <span class="string">&#x27;区域名称&#x27;</span>,</span><br><span class="line">  `create_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `create_by` VARCHAR(<span class="number">64</span>) COMMENT <span class="string">&#x27;创建人&#x27;</span>,</span><br><span class="line">  `update_by` VARCHAR(<span class="number">64</span>) COMMENT <span class="string">&#x27;修改人&#x27;</span>,</span><br><span class="line">  `remark` TEXT COMMENT <span class="string">&#x27;备注&#x27;</span></span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=<span class="string">&#x27;区域表&#x27;</span>;</span><br><span class="line"></span><br><span class="line">-- 插入测试数据</span><br><span class="line">INSERT INTO `tb_region` (`region_name`,`remark`) VALUES (<span class="string">&#x27;北京市朝阳区&#x27;</span>,<span class="string">&#x27;北京市朝阳区&#x27;</span>), (<span class="string">&#x27;北京市海淀区&#x27;</span>,<span class="string">&#x27;北京市海淀区&#x27;</span>), (<span class="string">&#x27;北京市东城区&#x27;</span>,<span class="string">&#x27;北京市东城区&#x27;</span>);</span><br><span class="line"></span><br><span class="line">CREATE TABLE `tb_partner` (</span><br><span class="line">  `id` INT AUTO_INCREMENT COMMENT <span class="string">&#x27;主键id&#x27;</span> PRIMARY KEY,</span><br><span class="line">  `partner_name` VARCHAR(<span class="number">255</span>) NOT NULL COMMENT <span class="string">&#x27;合作商名称&#x27;</span>,</span><br><span class="line">  `contact_person` VARCHAR(<span class="number">64</span>) COMMENT <span class="string">&#x27;联系人&#x27;</span>,</span><br><span class="line">  `contact_phone` VARCHAR(<span class="number">15</span>) COMMENT <span class="string">&#x27;联系电话&#x27;</span>,</span><br><span class="line">  `profit_ratio` INT COMMENT <span class="string">&#x27;分成比例&#x27;</span>,</span><br><span class="line">  `account` VARCHAR(<span class="number">64</span>) COMMENT <span class="string">&#x27;账号&#x27;</span>,</span><br><span class="line">  `password` VARCHAR(<span class="number">64</span>) COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  `create_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `create_by` VARCHAR(<span class="number">64</span>) COMMENT <span class="string">&#x27;创建人&#x27;</span>,</span><br><span class="line">  `update_by` VARCHAR(<span class="number">64</span>) COMMENT <span class="string">&#x27;修改人&#x27;</span>,</span><br><span class="line">  `remark` TEXT COMMENT <span class="string">&#x27;备注&#x27;</span></span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=<span class="string">&#x27;合作商表&#x27;</span>;</span><br><span class="line"></span><br><span class="line">-- 插入测试数据</span><br><span class="line">INSERT INTO `tb_partner` (`partner_name`, `contact_person`, `contact_phone`, `profit_ratio`, `account`, `password`) VALUES</span><br><span class="line">(<span class="string">&#x27;合作商A&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;13800138000&#x27;</span>, <span class="number">30</span>, <span class="string">&#x27;a001&#x27;</span>, <span class="string">&#x27;pwdA&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;合作商B&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;13912345678&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;b002&#x27;</span>, <span class="string">&#x27;pwdB&#x27;</span>);</span><br><span class="line"></span><br><span class="line">CREATE TABLE `tb_node` (</span><br><span class="line">  `id` INT AUTO_INCREMENT COMMENT <span class="string">&#x27;主键id&#x27;</span> PRIMARY KEY,</span><br><span class="line">  `node_name` VARCHAR(<span class="number">255</span>) NOT NULL COMMENT <span class="string">&#x27;点位名称&#x27;</span>,</span><br><span class="line">  `address` VARCHAR(<span class="number">255</span>) NOT NULL COMMENT <span class="string">&#x27;详细地址&#x27;</span>,</span><br><span class="line">  `business_type` INT COMMENT <span class="string">&#x27;商圈类型&#x27;</span>,</span><br><span class="line">  `region_id` INT COMMENT <span class="string">&#x27;区域ID&#x27;</span>,</span><br><span class="line">  `partner_id` INT COMMENT <span class="string">&#x27;合作商ID&#x27;</span>,</span><br><span class="line">  `create_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `create_by` VARCHAR(<span class="number">64</span>) COMMENT <span class="string">&#x27;创建人&#x27;</span>,</span><br><span class="line">  `update_by` VARCHAR(<span class="number">64</span>) COMMENT <span class="string">&#x27;修改人&#x27;</span>,</span><br><span class="line">  `remark` TEXT COMMENT <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">  FOREIGN <span class="title function_">KEY</span> <span class="params">(`region_id`)</span> REFERENCES `tb_region`(`id`) ON DELETE CASCADE ON UPDATE CASCADE,</span><br><span class="line">  FOREIGN <span class="title function_">KEY</span> <span class="params">(`partner_id`)</span> REFERENCES `tb_partner`(`id`) ON DELETE CASCADE ON UPDATE CASCADE</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=<span class="string">&#x27;点位表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 插入测试数据</span><br><span class="line">-- 假设区域ID为<span class="number">1</span>对应<span class="string">&#x27;北京市朝阳区&#x27;</span>，合作商ID为<span class="number">1</span>对应<span class="string">&#x27;合作商A&#x27;</span></span><br><span class="line">INSERT INTO `tb_node` (`node_name`, `address`, `business_type`, `region_id`, `partner_id`) VALUES</span><br><span class="line">(<span class="string">&#x27;三里屯点位&#x27;</span>, <span class="string">&#x27;北京市朝阳区三里屯路&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;五道口点位&#x27;</span>, <span class="string">&#x27;北京市海淀区五道口&#x27;</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><blockquote><p>然后是这三张表之间的关系：可以看到区域表跟点位表是一对多的关系，合作商表与点位表也是一对多的关系，一个区域里面或者是一个合作商都可以拥有多个点位。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_a0178a50.png" alt="pic_a0178a50.png"></p><blockquote><p>然后我们使用若依的代码生成器来生成区域管理相关代码</p></blockquote><p><img src="https://api.smain.cn/pics/pic_95dbd639.png" alt="pic_95dbd639.png"></p><p><img src="https://api.smain.cn/pics/pic_19566da6.png" alt="pic_19566da6.png"></p><p><img src="https://api.smain.cn/pics/pic_a1491b66.png" alt="pic_a1491b66.png"></p><blockquote><p>然后将生成的代码分别导入到你的前后端项目中，main 文件夹中生成的后端代码，vue 文件夹中生成的前端代码，下面的三条 sql 脚本是若依框架的动态菜单表，将这三张表导入以后就可以使用若依的菜单管理功能对这三张菜单进行动态管理。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_72575bda.png" alt="pic_72575bda.png"></p><p><img src="https://api.smain.cn/pics/pic_0f44480a.png" alt="pic_0f44480a.png"> <img src="https://api.smain.cn/pics/pic_97c44b56.png" alt="pic_97c44b56.png"></p><blockquote><p>然后启动项目进入到区域管理菜单模块，基础界面如下图所示：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_61267570.png" alt="pic_61267570.png"></p><h6 id="2-自定义框架"><a href="#2-自定义框架" class="headerlink" title="2.自定义框架"></a>2.自定义框架</h6><h6 id="2-1-问题分析"><a href="#2-1-问题分析" class="headerlink" title="2.1 问题分析"></a>2.1 问题分析</h6><blockquote><p>可以看到，若依帮我们生成的代码还是有很多问题的：</p></blockquote><blockquote><p>1.首先就是列表名 id，用 id 来当列表名其实是若依默认的，但这显然是不合适的的，所以我们要把 id 改为序号。</p><p>2.其次就是我们在刚刚建表时就对这三张表分析过了，区域表显然是更点位表有关联的，但是在页面上并没有体现出来，我们是想要在区域菜单中展示对应区域有多少个点位的！</p><p>3.除了基本的修改和删除，如果我还想要增加一个按键叫做“查看详情”，要求点击该按键后弹出该区域的详细信息因该怎么实现？</p></blockquote><h6 id="2-2-解决方法"><a href="#2-2-解决方法" class="headerlink" title="2.2 解决方法"></a>2.2 解决方法</h6><blockquote><p>下面我们针对这些问题一一来解决</p></blockquote><blockquote><p>首先是序号名称问题，我们将 lable 标签中的值修改掉就好了</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;el-table-column label=<span class="string">&quot;序号&quot;</span> align=<span class="string">&quot;center&quot;</span> prop=<span class="string">&quot;id&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><blockquote><p>然后是对应区域点位数量的问题，这个问题我们需要将其拆封成两个部分，第一部分是后端的视图封装，我们定义一个 RegionVo 类，来封装所要在前端展示的数据，由前面的分析可知我们希望展示点位数据，所以先继承原有的 Regon 类，然后在此基础上添加一个 nodeCount 变量用来存储对应的点位数量（变量名的定义因该尽量跟数据库对应数据类型的名字一样，并采用驼峰式命名风格）</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 使用驼峰命名法转换字段 --&gt;</span><br><span class="line">&lt;setting name=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> value=<span class="string">&quot;true&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p><img src="https://api.smain.cn/pics/pic_549657fb.png" alt="pic_549657fb.png"></p><blockquote><p>然后就是实现点位数量的查询，这里有两种实现思路</p><p>（1）同步存储：在区域表中有点位数的字段，当点位发生变化时，同步区域表中的点位数。</p><ul><li>优点：由于是单表查询操作，查询列表效率最高。</li><li>缺点：需要在点位增删改时修改区域表中的数据，有额外的开销，数据也可能不一致。</li></ul><p>（2）关联查询：编写关联查询语句，在 mapper 层封装。</p><ul><li>优点：实时查询，数据 100%正确，不需要单独维护。</li><li>缺点：SQL 语句较复杂，如果数据量大，性能比较低。</li></ul><p>由于区域和点位表，记录个数都不是很多，所以我们采用关联查询这种方案。</p></blockquote><blockquote><p>SQL 查询：先聚合统计每个区域的点位数，然后与区域表进行关联查询</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select r.id, r.region_name, r.remark, ifnull(n.node_count, <span class="number">0</span>) as node_count</span><br><span class="line">from  tb_region r left <span class="title function_">join</span></span><br><span class="line"><span class="params">(select region_id, count(*)</span> as node_count</span><br><span class="line">from tb_node group by region_id) n on r.id = n.region_id</span><br></pre></td></tr></table></figure><blockquote><p>先在查询中测试这段 sql 代码，运行结果没问题后再放入 mapper.xml 中。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_dd2a6197.png" alt="pic_dd2a6197.png"></p><p><img src="https://api.smain.cn/pics/pic_c878a3e5.png" alt="pic_c878a3e5.png"></p><blockquote><p>加 where 的原因是为了动态地生成 SQL 查询的 <code>WHERE</code> 子句，它可以帮助避免因条件拼接时的语法错误，自动处理 <code>WHERE</code> 关键字和 <code>AND</code> 的连接问题。</p></blockquote><blockquote><p>然后即使基本的 mapper 层、service 层、servviceipml 层、controller 层的编写，这里就快速过一下代码。</p></blockquote><p>RegionMapper</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询区域管理列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> region</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> RegionVo集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;RegionVo&gt; <span class="title function_">selectRegionVoList</span><span class="params">(Region region)</span>;</span><br></pre></td></tr></table></figure><p>IRegionService</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询区域管理列表，带点位数量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> region 区域管理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> RegionVo集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> List&lt;RegionVo&gt; <span class="title function_">selectRegionVoList</span><span class="params">(Region region)</span>;</span><br></pre></td></tr></table></figure><p>RegionServiceImpl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询区域管理列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> region</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> RegionVo集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;RegionVo&gt; <span class="title function_">selectRegionVoList</span><span class="params">(Region region)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> regionMapper.selectRegionVoList(region);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RegionController</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询区域管理列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;@ss.hasPermi(&#x27;manage:region:list&#x27;)&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> TableDataInfo <span class="title function_">list</span><span class="params">(Region region)</span></span><br><span class="line">&#123;</span><br><span class="line">    startPage();</span><br><span class="line">    List&lt;RegionVo&gt; voList = regionService.selectRegionVoList(region);</span><br><span class="line">    <span class="keyword">return</span> getDataTable(voList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>到此后端代码改造完成，需要注意的是，除了在 Controller 层中对原有的 list 方法进行修改以外，剩下的几层都是新增方法，不要把之前的方法改掉！不然由于有一些接口比如数据导出，还是使用的 selectRegionList（）方法就会报错！</p></blockquote><blockquote><p>接下来让我们把目光转向前端，由于后端已经数据封装好了，这里只需要在 el-table-column 标签中指定 prop 属性即可。</p></blockquote><p>region&#x2F;index.vue</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;el-table-column label=<span class="string">&quot;点位数&quot;</span> align=<span class="string">&quot;center&quot;</span> prop=<span class="string">&quot;nodeCount&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><blockquote><p>修改完成后重新启动项目查看界面，没有问题点位数据成功显示！</p></blockquote><p><img src="https://api.smain.cn/pics/pic_884739fb.png" alt="pic_884739fb.png"></p><blockquote><p>没有显示成功的可以打开 F12 然后点击一下重置按钮看一下数据返回没有，如果有下面的数据就证明后端没有问题，检查前端代码写错没有，如果连数据都没有返回，就证明是后端代码哪里写错了，以我的经验来看一般都是数据库查询的时候出问题。</p></blockquote><blockquote><p>遇到 bug 的时候不要怕！根据报错信息一步步寻找错误，学会使用断点进行调试和 log.info(需用引入 SLF4J 依赖)输出日志信息，修改 bug 的过程就是你对项目结构进一步加深了解的过程！</p></blockquote><p><img src="https://api.smain.cn/pics/pic_c82ce8dc.png" alt="pic_c82ce8dc.png"></p><blockquote><p>最后我们来填第三个坑，实现查看详情按钮。</p></blockquote><blockquote><p>还是先来分析一下，我们最后想要实现下图的效果，点击查询详情后弹出下面的提示框，提示框中显示了区域名称和包含的点位，显然点位是用一个 List<NodeVo> 对象来存储的，这里又涉及到一个坑了，设备数量在哪里呢？这里为了不再增加复杂度并且考虑到连贯性的关系，就不再对点位表进行改造了，我们修改一下需求，只显示区域包括的点位名称，不显示设备数量。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_9bd96557.png" alt="pic_9bd96557.png"></p><blockquote><p>要查询点位数据，我们就要用到前端的 node.js 中的 listNode 方法</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询点位管理列表</span></span><br><span class="line">export function <span class="title function_">listNode</span><span class="params">(query)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> request(&#123;</span><br><span class="line">    url: <span class="string">&#x27;/manage/node/list&#x27;</span>,</span><br><span class="line">    method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    params: query</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>该方法调用后端的 list 方法查询点位数据</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询点位管理列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@PreAuthorize(&quot;@ss.hasPermi(&#x27;manage:node:list&#x27;)&quot;)</span></span><br><span class="line"> <span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> TableDataInfo <span class="title function_">list</span><span class="params">(Node node)</span></span><br><span class="line">    &#123;</span><br><span class="line">        startPage();</span><br><span class="line">        List&lt;Node&gt; list = nodeService.selectNodeList(node);</span><br><span class="line">        <span class="keyword">return</span> getDataTable(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后我们在<code>&lt;script&gt;</code>中来编写 <code>getRegionInfo</code> 方法，并绑定按键</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-button</span></span></span><br><span class="line"><span class="tag">  <span class="attr">link</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">click</span>=<span class="string">&quot;getRegionInfo(scope.row)&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-hasPermi</span>=<span class="string">&quot;[&#x27;manage:node:list&#x27;]&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span>查看详情&lt;/el-button</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><blockquote><p>记得引入 js 代码</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  listRegion,</span><br><span class="line">  getRegion,</span><br><span class="line">  delRegion,</span><br><span class="line">  addRegion,</span><br><span class="line">  updateRegion,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;@/api/manage/region&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; listNode &#125; <span class="keyword">from</span> <span class="string">&quot;@/api/manage/node&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; loadAllParams &#125; <span class="keyword">from</span> <span class="string">&quot;@/api/page&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 查看详情按钮操作 */</span></span><br><span class="line"><span class="keyword">const</span> nodeList = <span class="title function_">ref</span>([]);</span><br><span class="line"><span class="keyword">const</span> regionInfoOpen = <span class="title function_">ref</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getRegionInfo</span>(<span class="params">row</span>) &#123;</span><br><span class="line">  <span class="comment">// 查询区域信息</span></span><br><span class="line">  <span class="title function_">reset</span>();</span><br><span class="line">  <span class="keyword">const</span> _id = row.<span class="property">id</span>;</span><br><span class="line">  <span class="title function_">getRegion</span>(_id).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    form.<span class="property">value</span> = response.<span class="property">data</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 查询点位列表</span></span><br><span class="line">  loadAllParams.<span class="property">regionId</span> = row.<span class="property">id</span>;</span><br><span class="line">  <span class="title function_">listNode</span>(loadAllParams).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    nodeList.<span class="property">value</span> = response.<span class="property">rows</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  regionInfoOpen.<span class="property">value</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>下面是对这一段 javascript 代码的详细解释，本问题的关键所在就是这段代码，有了这段代码才能够拿到数据。</p><ol><li><code>const nodeList = ref([]);</code></li></ol><ul><li>这行代码定义了一个响应式变量 <code>nodeList</code>，初始值为空数组。</li><li><code>ref</code> 是 Vue.js Composition API 提供的用于创建响应式数据的函数，<code>nodeList</code> 会随着值的变化自动触发视图更新。</li></ul><ol start="2"><li><code>const regionInfoOpen = ref(false);</code></li></ol><ul><li>定义了另一个响应式变量 <code>regionInfoOpen</code>，初始值为 <code>false</code>。</li><li>这个变量用来控制区域信息详情的显示状态，当 <code>regionInfoOpen</code> 为 <code>true</code> 时，详情会显示。</li></ul><ol start="3"><li><code>function getRegionInfo(row) &#123; ... &#125;</code></li></ol><ul><li>定义了一个函数 <code>getRegionInfo</code>，用于处理查看区域详情的操作。</li><li>参数 <code>row</code> 是一个对象，通常表示区域的某一行数据。</li></ul><ol start="4"><li><code>reset();</code></li></ol><ul><li>调用了一个 <code>reset()</code> 函数，可能用于重置表单或页面状态，以清除之前的数据。具体的实现不在这段代码中。</li></ul><ol start="5"><li><code>const _id = row.id</code></li></ol><ul><li>获取 <code>row</code> 对象的 <code>id</code> 属性值，并将其存储在 <code>_id</code> 变量中，用于后续的查询操作。</li></ul><ol start="6"><li><code>getRegion(_id).then(response =&gt; &#123; ... &#125;)</code></li></ol><ul><li>调用 <code>getRegion</code> 方法获取区域的详细信息，<code>_id</code> 作为查询参数。</li><li><code>getRegion</code> 应该是一个返回 Promise 的函数，使用 <code>.then</code> 方法处理异步响应。</li><li>如果请求成功，<code>response.data</code> 会赋值给 <code>form.value</code>，其中 <code>form</code> 应该是另一个 <code>ref</code> 响应式变量，用于绑定表单数据。</li></ul><ol start="7"><li><code>loadAllParams.regionId = row.id;</code></li></ol><ul><li>更新 <code>loadAllParams</code> 对象的 <code>regionId</code> 属性为当前区域的 <code>id</code>，用于查询点位列表。</li></ul><ol start="8"><li><code>listNode(loadAllParams).then(response =&gt; &#123; ... &#125;)</code></li></ol><ul><li>调用 <code>listNode</code> 方法获取与当前区域相关的点位列表，<code>loadAllParams</code> 作为查询参数。</li><li><code>listNode</code> 也是一个返回 Promise 的函数，异步处理响应结果。</li><li>请求成功时，将返回的数据（<code>response.rows</code>）赋值给 <code>nodeList.value</code>，更新点位列表。</li></ul><ol start="9"><li><code>regionInfoOpen.value = true;</code></li></ol><ul><li>将 <code>regionInfoOpen</code> 的值设置为 <code>true</code>，表示区域信息详情的弹窗或面板应该显示。</li></ul></blockquote><blockquote><p>理解完了这段代码后，最后就是编写一个提示框，绑定对应的数据即可！</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 查看详情对话框 --&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">el-dialog</span> <span class="attr">title</span>=<span class="string">&quot;区域详情&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;regionInfoOpen&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500px&quot;</span> <span class="attr">append-to-body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;区域名称&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;regionName&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;form.regionName&quot;</span> <span class="attr">disabled</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">label</span>&gt;</span>包含点位：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">el-table</span> <span class="attr">:data</span>=<span class="string">&quot;nodeList&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">&quot;序号&quot;</span> <span class="attr">type</span>=<span class="string">&quot;index&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">&quot;点位名称&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;nodeName&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">el-dialog</span>&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>欧克，做完这一步之后就可以重新启动项目进行测试了。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_92b16645.png" alt="pic_92b16645.png"></p><blockquote><p>可以看到点击查看详情后成功返回提示框！</p></blockquote><blockquote><p>到此，自定义若依框架的一些基本步骤都已经演示完毕，如果你认真的看到了这里并且自己动手试验了，那么我相信你一定对若依框架有了更深刻的了解和认识，当然，由于本文只是若依的基础入门讲解，所以只是定义了一些基础的功能，若依能做的远远不止这些，例如定时任务调度，数据可视化报表等等，笔者也是水平有限，如果有什么错误敬请指正，希望能和大家一起学习一起进步！</p></blockquote><h4 id="四、结语"><a href="#四、结语" class="headerlink" title="四、结语"></a>四、结语</h4><blockquote><p>到这里，若依框架的基本使用方法已经介绍完毕。需要注意的是，虽然若依的代码生成器极大地提高了开发效率，方便快捷地生成基本的增删改查功能，但对于较为复杂的业务场景，例如多表联查或复杂的业务逻辑处理，仍需要开发者自行进行调整和优化。这也为我们提供了更多的灵活性，可以根据实际需求对代码进行更深入的定制化开发。</p></blockquote><blockquote><p>前路漫漫道阻且长，砥砺前行与君共勉！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
