<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode416.分割等和子集【中等】</title>
      <link href="/2025/04/07/LeetCode416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91/"/>
      <url>/2025/04/07/LeetCode416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="相关标签："><a href="#相关标签：" class="headerlink" title="相关标签："></a>相关标签：</h2><blockquote><p>数组、动态规划</p></blockquote><h2 id="题目简介："><a href="#题目简介：" class="headerlink" title="题目简介："></a>题目简介：</h2><blockquote><p>给你一个 只包含正整数 的 非空 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p></blockquote><h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><blockquote><p>示例 1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：数组可以分割成 [<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>] 和 [<span class="number">11</span>] 。</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>示例 2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：数组不能分割成两个元素和相等的子集。</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul></blockquote><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><blockquote><p>题目要求我们分割等和子集，那首先想到的就是排除和为奇数的情况，当和为偶数时才有讨论的必要。我们现在的目标就变成了判断能否从数组中找出一些元素凑成总和的一半。</p><p>诶，这个描述是不是有一点耳熟，我换一个说法你就明白了，给你一个背包，让你判断能否将背包装满。所以这道题本质上就是背包问题，而且是 01 背包问题（不允许重复）。</p><p>唯一需要注意的一点就是这里的 dp 数组需要定义成 boolean 类型同时状态转移的条件也要做适宜的改动。</p></blockquote><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果为奇数那就肯定不可能分成两个等和子集</span></span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 现在就是看数组中的元素能否凑够half了</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// dp[i] 表示能否凑出i</span></span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[half + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 这里要先初始化一下</span></span><br><span class="line">        <span class="comment">// 初不初始化要看你的具体问题，比如我这里0肯定满足要求所以要初始化</span></span><br><span class="line">        <span class="comment">// 而像经典的背包问题就是不需要初始化的，应为当背包为空时肯定对应价值也为0</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> half; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">                <span class="comment">// 从后往前遍历保证当前的值是上一次遍历的结果，而不是当前遍历的结果由此来保证唯一性</span></span><br><span class="line">                <span class="keyword">if</span> (dp[j - nums[i]]) &#123;</span><br><span class="line">                    dp[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[half];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h2><blockquote><p>这里再由此引申一下背包问题</p><p>背包问题通常分为 4 种</p><ul><li>01 背包问题</li><li>完全背包问题</li><li>多重背包问题</li><li>分组背包问题</li></ul></blockquote><blockquote><p>这里只简单提一下前面两种，如果需要详细学习可以参考下面的文章：</p><p><a href="https://blog.csdn.net/2301_79558858/article/details/137546255?ops_request_misc=%257B%2522request%255Fid%2522%253A%25220fc10c1a82166811625662ee4adfe67b%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=0fc10c1a82166811625662ee4adfe67b&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-137546255-null-null.142%5Ev102%5Epc_search_result_base3&utm_term=%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98&spm=1018.2226.3001.4187">背包问题详解（01 背包，完全背包，多重背包，分组背包）-CSDN 博客</a></p></blockquote><blockquote><p>背包问题：</p><p>给定容量为 W 的背包和 N 个物品，每个物品有重量 W[i]和价值 V[i]</p></blockquote><blockquote><p>01 背包问题</p><p>内层循环逆序遍历（保证每个物品只选一次）</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[W + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> W; j &gt;= w[i]; j--) &#123;</span><br><span class="line">        dp[j] = Math.max(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如何理解反向遍历就可以保证唯一性：</p><p>通过从大到小遍历，我们可以保证在更新 dp[i] 时，dp[i - num] 的值是上一次遍历的结果，而不是当前遍历的结果。</p></blockquote><blockquote><p>完全背包问题</p><p>内层循环正序遍历（允许重复选择）</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[W + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> w[i]; j &lt;= W; j++) &#123;</span><br><span class="line">        dp[j] = Math.max(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode368.最大整除子集【中等】</title>
      <link href="/2025/04/06/LeetCode368-%E6%9C%80%E5%A4%A7%E6%95%B4%E9%99%A4%E5%AD%90%E9%9B%86%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91/"/>
      <url>/2025/04/06/LeetCode368-%E6%9C%80%E5%A4%A7%E6%95%B4%E9%99%A4%E5%AD%90%E9%9B%86%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="相关标签："><a href="#相关标签：" class="headerlink" title="相关标签："></a>相关标签：</h2><blockquote><p>数组、动态规划</p></blockquote><h2 id="题目简介："><a href="#题目简介：" class="headerlink" title="题目简介："></a>题目简介：</h2><blockquote><p>给你一个由 无重复 正整数组成的集合 <code>nums</code> ，请你找出并返回其中最大的整除子集 <code>answer</code> ，子集中每一元素对 <code>(answer[i], answer[j])</code> 都应当满足：</p><ul><li><code>answer[i] % answer[j] == 0</code> ，或</li><li><code>answer[j] % answer[i] == 0</code></li></ul><p>如果存在多个有效解子集，返回其中任何一个均可。</p></blockquote><h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><blockquote><p>示例 1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">解释：[<span class="number">1</span>,<span class="number">3</span>] 也会被视为正确答案。</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>示例 2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= 2 * 109</code></li><li><code>nums</code> 中的所有整数 互不相同</li></ul></blockquote><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><blockquote><p>这道题其实一开始我还是想的是先求出所有子集，然后对于每个子集去判断是否能够满足相互整除的要求。但是看了一下 nums 数组的长度好吧这个做法肯定会超内存限制。</p><p>然后我想到提前剪枝先去判断 nums 中是否有满足相互整除的一对元素，如果没有就说明最大的整除子集的大小就是 1 了，所以只需要从 nums 中任意取出一个元素返回即可，如果有这样一对元素那就说明最大的整除子集大小大于 1，这样就可以不去存取大小为 1 的子集可以节约一点内存。</p><p>但是一顿分析过后发现本质上空间复杂度还是 2 的 n 次方，所以先存储子集的做法肯定是行不通了。</p></blockquote><blockquote><p>看了一下本题的标签有一个动态规划，不是这怎么和动态规划扯上关系的？</p><p>dp[i]能表示什么？我们想要找出满足要求的最大子集，但是我们又不能直接存储子集，所以我们可以用 dp[i]来表示以 nums[i]结尾的最大整除子集的大小。</p><p>使用两层循环，外层遍历 nums 内层从 nums[0]遍历到当前元素 nums[i - 1]在遍历的过程中去判断当前元素是否能够被 nums[i]整除如果能够整除就证明它满足要求可以被加入到子集中去这个时候就可以使用状态转移方程转移 dp[i]的状态。不过本题要求双向整除都可以，所以为了简化判断条件我们可以先对 nums 进行一次升序排序，这样就只需要去判断大的整除小的了。</p></blockquote><blockquote><p>下面是具体实现步骤：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] % nums[j] == <span class="number">0</span> &amp;&amp; dp[j] + <span class="number">1</span> &gt; dp[i]) &#123;</span><br><span class="line">            <span class="comment">// 跟新dp</span></span><br><span class="line">            dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是现在还有一个问题要解决：</p><p>dp 只能解决找到最大的子集的大小，但是不能记录这个子集中有哪些元素。</p><p>怎么解决呢？</p><p>其实只需要再引入一个路径数组 pre[]在每次 dp 跟新的时候同时记录当前元素的下标即可，不过需要注意的是这个路径数组记录的是前缀路径对于最后一步是没有记录的，所以这里我们还要再定义一个变量 maxIndex 来记录当前 dp[]的最后一个元素。同时再使用一个变量 maxSize 来记录最长子集的大小。</p></blockquote><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">largestDivisibleSubset</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 把数组排序一下，这样就只用讨论从后面对于前面取模</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// dp[i] 表示以nums[i]结尾的最大整除子集的大小</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// pre用来存储转移路径为了最后构造结果集合</span></span><br><span class="line">        <span class="type">int</span>[] pre = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        Arrays.fill(pre, -<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] % nums[j] == <span class="number">0</span> &amp;&amp; dp[j] + <span class="number">1</span> &gt; dp[i]) &#123;</span><br><span class="line">                    <span class="comment">// 跟新dp和前缀索引</span></span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                    pre[i] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; maxSize) &#123;</span><br><span class="line">                <span class="comment">// 跟新最大子集信息</span></span><br><span class="line">                maxSize = dp[i];</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造结果集合</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(maxIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">            res.add(nums[maxIndex]);</span><br><span class="line">            maxIndex = pre[maxIndex];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h2><blockquote><p>做完这道题我受到了启发，leetcode300 最长递增子序列的变式，要求不仅使用 dp 求出最长子序列的长度，还要将这个子序列给保存下来</p><p>那不就是相当于再用一个 pre 路径数组来记录子序列的下标吗？有了这些下标那最后就可以还原出最长子序列了！！！</p></blockquote><blockquote><p>这里贴一下修改后的代码，如果想看原题的可以点下面的链接跳转</p></blockquote><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/?envType=study-plan-v2&envId=top-100-liked">300. 最长递增子序列 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// dp[i] 表示值在 [0, i - 1] 范围内的严格递增的数有多少</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] pre = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 每个元素至少可以单独构成一个子序列</span></span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        Arrays.fill(pre, -<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i] &amp;&amp; dp[j] + <span class="number">1</span> &gt; dp[i]) &#123;</span><br><span class="line">                    <span class="comment">// 用一个数组去记录前面的情况，这样当前位置就能够不断的去更新最大值</span></span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                    pre[i] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新最大的dp[i]</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; maxLength) &#123;</span><br><span class="line">                maxLength = dp[i];</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (maxIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">            res.add(nums[maxIndex]);</span><br><span class="line">            maxIndex = pre[maxIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode1863-找出所有子集的异或和再求和【简单】</title>
      <link href="/2025/04/05/LeetCode1863-%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86%E7%9A%84%E5%BC%82%E6%88%96%E5%92%8C%E5%86%8D%E6%B1%82%E5%92%8C%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91/"/>
      <url>/2025/04/05/LeetCode1863-%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86%E7%9A%84%E5%BC%82%E6%88%96%E5%92%8C%E5%86%8D%E6%B1%82%E5%92%8C%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="相关标签："><a href="#相关标签：" class="headerlink" title="相关标签："></a>相关标签：</h2><blockquote><p>位运算、数组、回溯</p></blockquote><h2 id="题目简介："><a href="#题目简介：" class="headerlink" title="题目简介："></a>题目简介：</h2><blockquote><p>一个数组的 异或总和 定义为数组中所有元素按位 <code>XOR</code> 的结果；如果数组为 空 ，则异或总和为 <code>0</code> 。</p><ul><li>例如，数组 <code>[2,5,6]</code> 的 异或总和 为 <code>2 XOR 5 XOR 6 = 1</code> 。</li></ul><p>给你一个数组 <code>nums</code> ，请你求出 <code>nums</code> 中每个 子集 的 异或总和 ，计算并返回这些值相加之 和 。</p><p>注意：在本题中，元素 相同 的不同子集应 多次 计数。</p><p>数组 <code>a</code> 是数组 <code>b</code> 的一个 子集 的前提条件是：从 <code>b</code> 删除几个（也可能不删除）元素能够得到 <code>a</code> 。</p></blockquote><h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><blockquote><p>示例 1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：[<span class="number">1</span>,<span class="number">3</span>] 共有 <span class="number">4</span> 个子集：</span><br><span class="line">- 空子集的异或总和是 <span class="number">0</span> 。</span><br><span class="line">- [<span class="number">1</span>] 的异或总和为 <span class="number">1</span> 。</span><br><span class="line">- [<span class="number">3</span>] 的异或总和为 <span class="number">3</span> 。</span><br><span class="line">- [<span class="number">1</span>,<span class="number">3</span>] 的异或总和为 <span class="number">1</span> XOR <span class="number">3</span> = <span class="number">2</span> 。</span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> + <span class="number">3</span> + <span class="number">2</span> = <span class="number">6</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>示例 2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">28</span></span><br><span class="line">解释：[<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>] 共有 <span class="number">8</span> 个子集：</span><br><span class="line">- 空子集的异或总和是 <span class="number">0</span> 。</span><br><span class="line">- [<span class="number">5</span>] 的异或总和为 <span class="number">5</span> 。</span><br><span class="line">- [<span class="number">1</span>] 的异或总和为 <span class="number">1</span> 。</span><br><span class="line">- [<span class="number">6</span>] 的异或总和为 <span class="number">6</span> 。</span><br><span class="line">- [<span class="number">5</span>,<span class="number">1</span>] 的异或总和为 <span class="number">5</span> XOR <span class="number">1</span> = <span class="number">4</span> 。</span><br><span class="line">- [<span class="number">5</span>,<span class="number">6</span>] 的异或总和为 <span class="number">5</span> XOR <span class="number">6</span> = <span class="number">3</span> 。</span><br><span class="line">- [<span class="number">1</span>,<span class="number">6</span>] 的异或总和为 <span class="number">1</span> XOR <span class="number">6</span> = <span class="number">7</span> 。</span><br><span class="line">- [<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>] 的异或总和为 <span class="number">5</span> XOR <span class="number">1</span> XOR <span class="number">6</span> = <span class="number">2</span> 。</span><br><span class="line"><span class="number">0</span> + <span class="number">5</span> + <span class="number">1</span> + <span class="number">6</span> + <span class="number">4</span> + <span class="number">3</span> + <span class="number">7</span> + <span class="number">2</span> = <span class="number">28</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>示例 3：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">输出：<span class="number">480</span></span><br><span class="line">解释：每个子集的全部异或总和值之和为 <span class="number">480</span> 。</span><br></pre></td></tr></table></figure></blockquote><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><blockquote><p>本题我首先想到的就是首先求出数组的所有子集，根据题目的要求这个子集包含空集和全集，所以求取子集我第一个想到的方法就是使用回溯算法，拿到每一个子集后再分别遍历去求异或的值最后再加起来就可以得到答案了</p></blockquote><blockquote><p>这里值得一说的就是回溯算法，其实不管是求取子集还是求取全排列，回溯算法的核心思路就是在循环遍历的时候先将当前值加到临时集合里面去，然后再次递归调用同时将循环向后移动一位，最后就是删除掉临时集合的最后一个元素，这三步是比较固定的，唯一不同的点就是什么时候将临时集合加到目标集合里面去，这就要根据题目的要求来判断了。</p></blockquote><p>求子集：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 我这里习惯于将这两个集合设置为全局变量，这样就不用在函数中传递了</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 回溯的两个参数非别为nums数组和开始遍历的下标</span></span><br><span class="line">        backtrace(<span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrace</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 由于子集没有条件所以直接加入</span></span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(temp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 第一步</span></span><br><span class="line">            temp.add(nums[i]);</span><br><span class="line">            <span class="comment">// 第二步</span></span><br><span class="line">            backtrace(i + <span class="number">1</span>, nums);</span><br><span class="line">            <span class="comment">// 第三步</span></span><br><span class="line">            temp.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求全排列：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        backtrack(nums,set);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, List&lt;Integer&gt; temp, HashSet&lt;Integer&gt; set, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据本题条件要求长度跟nums一样时才加入</span></span><br><span class="line">        <span class="keyword">if</span> (temp.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(temp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(num)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.add(num);</span><br><span class="line">            set.add(num);</span><br><span class="line">            backtrack(nums, temp, set, res);</span><br><span class="line">            set.remove(num);</span><br><span class="line">            temp.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><blockquote><p>经过上面这么长的铺垫，相信这道题已经没有什么难点了</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subsetXORSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 先求出所有的子集</span></span><br><span class="line">        backtrace(nums, list, temp, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 再计算每一个子集的异或并求和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; arr = list.get(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.size(); j++) &#123;</span><br><span class="line">                flag ^= arr.get(j);</span><br><span class="line">            &#125;</span><br><span class="line">            res += flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用回溯算法可以很自然的求出nums的所有子集</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrace</span><span class="params">(<span class="type">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; temp, <span class="type">int</span> begin)</span> &#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(temp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt; nums.length; i++) &#123;</span><br><span class="line">            temp.add(nums[i]);</span><br><span class="line">            backtrace(nums, list, temp, i + <span class="number">1</span>);</span><br><span class="line">            temp.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他解法："><a href="#其他解法：" class="headerlink" title="其他解法："></a>其他解法：</h2><blockquote><p>我们发现其实只要将所有的元素进行一边或运算（|），然后再将结果左移数组的长度减一个单位最后得到的结果即为最终答案</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subsetXORSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">or</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            or |= x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> or &lt;&lt; (nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细的推导过程可以见：</p><p><a href="https://leetcode.cn/problems/sum-of-all-subset-xor-totals/solutions/3614974/on-shu-xue-zuo-fa-pythonjavaccgojsrust-b-9txy/?envType=daily-question&envId=2025-04-05">1863. 找出所有子集的异或总和再求和 - 力扣（LeetCode）</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo框架和Butterfly主题搭建个人博客网站</title>
      <link href="/2025/02/11/%E5%9F%BA%E4%BA%8EHexo%E6%A1%86%E6%9E%B6%E5%92%8CButterfly%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"/>
      <url>/2025/02/11/%E5%9F%BA%E4%BA%8EHexo%E6%A1%86%E6%9E%B6%E5%92%8CButterfly%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><blockquote><p>个人博客无疑是很多开发者、技术爱好者记录技术经验、分享生活和展示个人作品的一个重要平台。作为一名开发者，搭建一个属于自己的博客网站不仅是一个展示自我的窗口，还能帮助自己总结学习成果，提升技术水平。</p><p>在这篇博客中，我将带你一起走过基于 Hexo 框架搭建个人博客的全过程，同时介绍如何使用 Butterfly 主题来美化博客，使其更加符合个人风格。</p></blockquote><blockquote><p>下面展示一下我的个人博客网站：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_c8c3215b.png" alt="pic_c8c3215b.png"></p><h3 id="二、Hexo-框架简介"><a href="#二、Hexo-框架简介" class="headerlink" title="二、Hexo 框架简介"></a>二、Hexo 框架简介</h3><h4 id="2-1、什么是-Hexo？"><a href="#2-1、什么是-Hexo？" class="headerlink" title="2.1、什么是 Hexo？"></a>2.1、什么是 Hexo？</h4><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。 Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p><a href="https://hexo.io/zh-cn/">Hexo</a></p></blockquote><p><img src="https://api.smain.cn/pics/pic_0b118d77.png" alt="pic_0b118d77.png"></p><h4 id="2-2、安装"><a href="#2-2、安装" class="headerlink" title="2.2、安装"></a>2.2、安装</h4><blockquote><p>在安装 Hexo 之前需要先安装好 Git 和 Node.js:</p></blockquote><p><img src="https://api.smain.cn/pics/pic_5a252ec9.png" alt="pic_5a252ec9.png"></p><blockquote><p>Git 和 Node.js 的安装过程这里就不过多赘述了，下面进行 hexo 的安装：</p></blockquote><blockquote><p>hexo 的安装也非常简单，在终端运行以下代码：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><blockquote><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ hexo init MyBlog</span><br><span class="line">$ cd MyBlog</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h4 id="2-3、结构解析"><a href="#2-3、结构解析" class="headerlink" title="2.3、结构解析"></a>2.3、结构解析</h4><blockquote><p>初始化后，你的项目文件夹将如下所示：</p></blockquote><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── <span class="keyword">package</span>.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>_config.yml：</p><p>网站的配置文件。 你可以在此配置大部分的参数。</p></blockquote><blockquote><p>package.json：</p><p>应用程序的信息。 <a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> 渲染引擎 已默认安装，你可以自由移除。</p></blockquote><blockquote><p>scaffolds：</p><p>模板文件夹。 当你新建文章时，Hexo 会根据 scaffold 来创建文件。</p></blockquote><blockquote><p>source：</p><p>资源文件夹。 是存放用户资源的地方。 除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。 Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p></blockquote><blockquote><p>themes：</p><p>主题文件夹， Hexo 会根据主题来生成静态页面。</p></blockquote><p>到这里你的博客基础框架就搭好了，使用命令 hexo start 即可启动！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><blockquote><p>以上三条命令是 Hexo 中常用的命令，它们的作用分别是：</p></blockquote><blockquote><ul><li><p><code>hexo clean</code>：</p><ul><li>清理 Hexo 生成的缓存和已生成的静态文件。通常在你修改了配置或主题后运行此命令，确保生成的文件是最新的。</li><li>它会删除 <code>public</code> 目录中的所有文件和 <code>_posts</code> 目录中的缓存文件。</li></ul></li><li><p><code>hexo g</code>（<code>hexo generate</code>的简写）：</p><ul><li>生成 Hexo 博客的静态文件。运行这个命令后，Hexo 会根据你的 Markdown 文件生成对应的 HTML 文件，这些文件会被保存在 <code>public</code> 目录下。你可以通过浏览器访问这个目录下的文件，查看你的博客页面。</li></ul></li><li><p><code>hexo s</code>（<code>hexo server</code>的简写）：</p><ul><li>启动 Hexo 内置的本地开发服务器。运行此命令后，Hexo 会启动一个本地 Web 服务器，默认地址是 <code>http://localhost:4000</code>。你可以在浏览器中打开这个地址，实时查看博客效果。</li><li>这个命令非常适合在本地调试和查看博客效果，修改内容后，刷新浏览器即可看到变化。</li></ul></li></ul></blockquote><blockquote><p>一般我们本地测试修改界面样式后使用如下命令即可刷新界面：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hexo cl; hexo s</span><br></pre></td></tr></table></figure><p><img src="https://api.smain.cn/pics/pic_7e7b4c21.png" alt="pic_7e7b4c21.png"></p><h4 id="2-4、如何写文章？"><a href="#2-4、如何写文章？" class="headerlink" title="2.4、如何写文章？"></a>2.4、如何写文章？</h4><blockquote><p>在<code>\scaffolds\post.md</code>文件中，可以修改文章的默认模板，比如：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123; title &#125;&#125;</span><br><span class="line">date: &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123; date &#125;&#125;</span><br><span class="line">categories: &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123; categories &#125;&#125;</span><br><span class="line">tags: &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123; tags &#125;&#125;</span><br><span class="line">description: &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123; description &#125;&#125;</span><br><span class="line">top_img: &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123; top_img &#125;&#125;</span><br><span class="line">cover: &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123; cover &#125;&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><blockquote><p>然后在终端运行如下命令即可创建文章：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">&quot;文章标题&quot;</span> --template post</span><br></pre></td></tr></table></figure><blockquote><p>注意 hexo 默认文章格式只支持 Markdown，你会用 markdown 语法最好，不会也没有关系，网上有很多转换成 markdown 格式的在线编辑器。</p></blockquote><h3 id="三、基于-GitHub-Pages-部署"><a href="#三、基于-GitHub-Pages-部署" class="headerlink" title="三、基于 GitHub Pages 部署"></a>三、基于 GitHub Pages 部署</h3><blockquote><p>搭好了个人博客，虽然在本地可以运行，但如果想让其他人也能访问，就得部署到线上。需要购买服务器吗？不不不，Hexo 自带的插件可以直接将博客部署到 GitHub Pages，完全不需要额外的服务器！</p></blockquote><h4 id="3-1、什么是-GitHub-Pages？"><a href="#3-1、什么是-GitHub-Pages？" class="headerlink" title="3.1、什么是 GitHub Pages？"></a>3.1、什么是 GitHub Pages？</h4><blockquote><p>GitHub Pages 是 GitHub 提供的一项静态网站托管服务，允许用户直接通过 GitHub 仓库托管和发布个人或项目的静态网页。它非常适合用于展示个人博客、项目文档、个人作品集等内容。GitHub Pages 是免费的，并且提供了一个简单的发布流程，尤其适合开发者和技术人员使用。</p></blockquote><blockquote><p>GitHub Pages 的特点：</p></blockquote><blockquote><ul><li>免费托管：GitHub Pages 是免费的，只要你有一个 GitHub 账户，就可以使用这项服务。</li><li>支持自定义域名：你可以将自己的域名绑定到 GitHub Pages 托管的网站。</li><li>支持 HTTPS：GitHub Pages 会自动为你的网站提供 HTTPS 加密连接，确保网站的安全性。</li><li>与 GitHub 仓库集成：网站内容直接从 GitHub 仓库的文件生成和托管。你可以利用 GitHub 的版本控制功能来管理网站的更新和历史记录。</li><li>快速部署：通过简单的 Git 操作，你可以将博客或网站的内容直接从本地推送到 GitHub 上发布到网上。</li></ul></blockquote><h4 id="3-2、如何部署到-GitHub-Pages"><a href="#3-2、如何部署到-GitHub-Pages" class="headerlink" title="3.2、如何部署到 GitHub Pages"></a>3.2、如何部署到 GitHub Pages</h4><blockquote><p>创建一个 GitHub 仓库：首先，登录 GitHub，创建一个新的仓库。如果是个人网站，仓库名必须为 <code>your_username.github.io</code>（<code>your_username</code> 替换为你的 GitHub 用户名）。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_d9bce224.png" alt="pic_d9bce224.png"></p><blockquote><p>然后在你的 hexo 中运行如下命令：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><blockquote><p>修改配置文件<code>_config.yml：</code></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git<span class="meta">@github</span>.com:USERNAME/USERNAME.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><blockquote><p>然后执行以下命令：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#前面两个都介绍过，hexo d 是deployment的缩写，意为部署</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><blockquote><p>等待部署完成，打开你的博客地址（USERNAME.github.io），就可以看到你的博客了。</p></blockquote><h3 id="四、Butterfly-主题美化"><a href="#四、Butterfly-主题美化" class="headerlink" title="四、Butterfly 主题美化"></a>四、Butterfly 主题美化</h3><blockquote><p>通过之前的步骤，我们已经完成了博客的基本搭建。但是，Hexo 默认的界面比较简单，接下来，让我们一起美化一下博客，提升它的视觉效果！</p></blockquote><blockquote><p>打开 Hexo 官网，可以看到这里有许多好看的主题，大家可以根据自己的喜好选择。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_4545e07c.png" alt="pic_4545e07c.png"></p><blockquote><p>下面我以 Butterfly 主题来演示：</p></blockquote><h4 id="4-1、安装-Butterfly-主题"><a href="#4-1、安装-Butterfly-主题" class="headerlink" title="4.1、安装 Butterfly 主题"></a>4.1、安装 Butterfly 主题</h4><blockquote><p>在你的终端运行如下命令：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">git clone -b master https:<span class="comment">//github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span></span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><blockquote><p>修改配置文件 <code>_config.yml</code> 中的 <code>theme</code> 项为 butterfly：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_c79b540c.png" alt="pic_c79b540c.png"></p><blockquote><p>建议:</p><ul><li>为了減少升级主题带来的不便，我们可以把主题文件夹中的 <code>_config.yml</code> 重命名为 <code>_config.butterfly.yml</code>，复制到 Hexo 根目录下与<code>_config.yml</code>同级。</li><li>Hexo 会自动合并主题中的<code>_config.yml</code>和 <code>_config.butterfly.yml</code> ，如果存在同名配置，会使用<code>_config.butterfly.yml</code>的配置，其优先度较高。所以像和博客网址相关联的固定资料可以设置在_config.yml 中，比如博客的标题、作者信息和邮箱等等资料，而和主题样式相关的配置放在 <code>_config.butterfly.yml</code> 中，那么在将来你想换一个主题是很方便的。</li></ul></blockquote><p><img src="https://api.smain.cn/pics/pic_5292e713.png" alt="pic_5292e713.png"></p><h4 id="4-2、安装插件"><a href="#4-2、安装插件" class="headerlink" title="4.2、安装插件"></a>4.2、安装插件</h4><h5 id="1、搜索插件"><a href="#1、搜索插件" class="headerlink" title="1、搜索插件"></a>1、搜索插件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><blockquote><p>效果是给你的网站增加一个搜索栏：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_18d2acad.png" alt="pic_18d2acad.png"></p><blockquote><p>更改配置文件 <code>_config.butterfly.yml：</code></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">use: local_search</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    # Local search</span><br><span class="line">    local_search:</span><br><span class="line">    enable: <span class="literal">true</span></span><br><span class="line">    labels:</span><br><span class="line">        input_placeholder: Search <span class="keyword">for</span> Posts</span><br><span class="line">        hits_empty: <span class="string">&quot;We didn&#x27;t find any results for the search: $&#123;query&#125;&quot;</span></span><br></pre></td></tr></table></figure><h5 id="2-、图片懒加载插件"><a href="#2-、图片懒加载插件" class="headerlink" title="2.、图片懒加载插件"></a>2.、图片懒加载插件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm install hexo-lazyload-image --save</span><br></pre></td></tr></table></figure><blockquote><p>效果是当图片资源加载时用设置的动态加载图片覆盖图片异常显示：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_33ac019c.png" alt="pic_33ac019c.png"></p><blockquote><p>在 <code>_config.yml</code> 中添加以下配置（注意是系统设置文件不是主题设置文件）：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lazyload:</span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  loadingImg: /img/loading.gif</span><br></pre></td></tr></table></figure><p><img src="https://api.smain.cn/pics/pic_3755c14a.png" alt="pic_3755c14a.png"></p><h5 id="3、字数统计插件"><a href="#3、字数统计插件" class="headerlink" title="3、字数统计插件"></a>3、字数统计插件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm install hexo-wordcount --save or yarn add hexo-wordcount</span><br></pre></td></tr></table></figure><blockquote><p>在 <code>_config.butterfly.yml</code> 中修改以下配置：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">wordcount:</span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  post_wordcount: <span class="literal">true</span></span><br><span class="line">  min2read: <span class="literal">true</span></span><br><span class="line">  total_wordcount: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="4-3、个性化设置"><a href="#4-3、个性化设置" class="headerlink" title="4.3、个性化设置"></a>4.3、个性化设置</h4><h5 id="1、修改顶部菜单"><a href="#1、修改顶部菜单" class="headerlink" title="1、修改顶部菜单"></a>1、修改顶部菜单</h5><blockquote><p>修改主题配置文件<code>_config.butterfly.yml：</code></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  首页: / || fas fa-home</span><br><span class="line">  归档: /archives/ || fas fa-archive</span><br><span class="line">  标签: /tags/ || fas fa-tags</span><br><span class="line">  分类: /categories/ || fas fa-folder-open</span><br><span class="line">  列表||fa fa-list || hide:</span><br><span class="line">    音乐: /music/ || fas fa-music</span><br><span class="line">    照片: /picture/ || fas fa-images</span><br><span class="line">    电影: /movies/ || fas fa-video</span><br><span class="line">  留言板: /comments/ || fas fa-envelope-open</span><br><span class="line">  友链: /link/ || fas fa-link</span><br><span class="line">  关于: /about/ || fas fa-heart</span><br></pre></td></tr></table></figure><blockquote><p>必须是 <code>/xxx/</code>，后面<code>||</code>分开，然后写图标名，如果不想显示图标，图标名可不写</p></blockquote><blockquote><p>注意这里只是创建了导航菜单的·标签，我们还要新建对应的标签页：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="title class_">page</span> tags</span><br><span class="line">......</span><br></pre></td></tr></table></figure><blockquote><p>然后加上对应的 type：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: <span class="number">2025</span>-<span class="number">02</span>-<span class="number">01</span> <span class="number">14</span>:<span class="number">40</span>:<span class="number">05</span></span><br><span class="line">type: <span class="string">&quot;tags&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><blockquote><p>其他的标签也是一样，最终效果如图：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_10471d95.png" alt="pic_10471d95.png"></p><h5 id="2-修改个人信息"><a href="#2-修改个人信息" class="headerlink" title="2. 修改个人信息"></a>2. 修改个人信息</h5><blockquote><p>修改配置文件 <code>_config.yml：</code></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">title: 标题</span><br><span class="line">subtitle: 副标题</span><br><span class="line">description: 个性签名</span><br><span class="line">keywords:</span><br><span class="line">author: 作者</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: Asia/Shanghai</span><br></pre></td></tr></table></figure><h5 id="3-修改侧边栏"><a href="#3-修改侧边栏" class="headerlink" title="3. 修改侧边栏"></a>3. 修改侧边栏</h5><blockquote><p>调整侧边栏位置：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">aside:</span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  hide: <span class="literal">false</span></span><br><span class="line">  button: <span class="literal">true</span></span><br><span class="line">  mobile: <span class="literal">true</span> # display on mobile</span><br><span class="line">  position: right # left or right</span><br></pre></td></tr></table></figure><blockquote><p>增加个人链接：</p></blockquote><blockquote><p>打开配置文件 <code>_config.butterfly.yml：</code></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 侧边栏的个人链接</span><br><span class="line"># Social media links</span><br><span class="line"># Formal:</span><br><span class="line">#   icon: link || the description || color</span><br><span class="line">social:</span><br><span class="line">  fas fa-book: https:<span class="comment">//blog.csdn.net/m0_74123949 || CSDN || &#x27;#d81e06&#x27;</span></span><br><span class="line">  fas fa-code-branch: https:<span class="comment">//gitee.com/Ywj-ee || Gitee || &#x27;#C71D23&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>在<code>aside</code>里的<code>card_author</code>更改个人信息：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">card_author:</span><br><span class="line">    enable: <span class="literal">true</span></span><br><span class="line">    description:</span><br><span class="line">    button:</span><br><span class="line">      enable: <span class="literal">true</span></span><br><span class="line">      icon: fab fa-github</span><br><span class="line">      text: Follow Me</span><br><span class="line">      link: https:<span class="comment">//github.com/Ywj-ch</span></span><br><span class="line">  card_announcement:</span><br><span class="line">    enable: <span class="literal">true</span></span><br><span class="line">    content: 欢迎来到我的博客！</span><br></pre></td></tr></table></figure><blockquote><p>提一下 fa-github 是框架自带的图标库，<code>Butterfly</code>支持<a href="https://fontawesome.com/icons?from=io">font-awesome v6</a>图标，当然你也可以根据自身需求进行定制。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_13e307a2.png" alt="pic_13e307a2.png"></p><h5 id="4-图片设置"><a href="#4-图片设置" class="headerlink" title="4. 图片设置"></a>4. 图片设置</h5><blockquote><p>图片放在在<code>/themes/butterfly/source/img文件夹下面就行</code></p></blockquote><blockquote><p>打开配置文件 <code>_config.butterfly.yml</code></p></blockquote><p>网站图标</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">favicon: /img/favicon.png</span><br></pre></td></tr></table></figure><p>头像</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">avatar:</span><br><span class="line">  img: /img/butterfly-icon.png</span><br><span class="line">  effect: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>背景</p><blockquote><p>背景建议是将封面图 index_img:不设置，直接设置 background: &#x2F;img&#x2F;背景图 2.jpg，然后将顶部图像设置为透明 default_top_img: rgba(0, 0, 0, 0)，这样的效果可以让你的背景图保持简洁（”一图流“）</p></blockquote><p>文章封面图</p><blockquote><p>打开<code>source/_posts/xxx.md</code>文章：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: XXXXX        # 标题</span><br><span class="line">tags: XXXXX         # 标签</span><br><span class="line">categories: XXXXX   # 分类</span><br><span class="line">description: XXXXX  # 描述</span><br><span class="line">top_img: XXXXX      # 顶部背景图</span><br><span class="line">cover: XXXXX        # 文章封面</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h5 id="5、代码块样式"><a href="#5、代码块样式" class="headerlink" title="5、代码块样式"></a>5、代码块样式</h5><blockquote><p>打开配置文件 <code>_config.butterfly.yml：</code></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">highlight_theme: mac  #  darker / pale night / light / ocean / mac / mac light / <span class="literal">false</span> 代码主题</span><br><span class="line">highlight_copy: <span class="literal">true</span> # 复制按钮</span><br><span class="line">highlight_lang: <span class="literal">false</span> # 是否显示代码语言</span><br><span class="line">highlight_shrink: <span class="literal">false</span> # <span class="literal">true</span>: 代码块默认不展开 / <span class="literal">false</span>: 代码块默认展开 | none: 展开并隐藏折叠按钮</span><br><span class="line">highlight_height_limit: <span class="literal">false</span> # unit: px</span><br><span class="line">code_word_wrap: <span class="literal">true</span> #代码自动换行，关闭滚动条</span><br></pre></td></tr></table></figure><blockquote><p>同时将站点配置文件<code>_config.yml</code>的<code>highlight</code>设置为<code>false：</code></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">highlight:</span><br><span class="line">  enable: <span class="literal">false</span></span><br><span class="line">  line_number: <span class="literal">false</span></span><br><span class="line">  auto_detect: <span class="literal">false</span></span><br></pre></td></tr></table></figure><h5 id="6、副标题循环打字效果"><a href="#6、副标题循环打字效果" class="headerlink" title="6、副标题循环打字效果"></a>6、副标题循环打字效果</h5><blockquote><p>打开配置文件 <code>_config.butterfly.yml：</code></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># The subtitle on homepage</span><br><span class="line">subtitle:</span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  effect: <span class="literal">true</span></span><br><span class="line">  loop: <span class="literal">true</span></span><br><span class="line">  source: <span class="literal">false</span></span><br><span class="line">  # 如果有英文逗号<span class="string">&#x27; , &#x27;</span>,请使用转义字元 ,</span><br><span class="line">  # 如果有英文双引号<span class="string">&#x27; &quot; &#x27;</span>,请使用转义字元 <span class="string">&quot;</span></span><br><span class="line"><span class="string">  sub:</span></span><br><span class="line"><span class="string">    - Dare to dream Live to shine! 🌟💫</span></span><br><span class="line"><span class="string">    - Time flows gently Cherish each moment! ⏳🍃</span></span><br></pre></td></tr></table></figure><blockquote><p>效果如下：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_822e59b5.png" alt="pic_822e59b5.png"></p><h4 id="4-4、鼠标样式魔改"><a href="#4-4、鼠标样式魔改" class="headerlink" title="4.4、鼠标样式魔改"></a>4.4、鼠标样式魔改</h4><blockquote><p>新建文件<code>[BlogRoot]\source\js\cursor.js（默认是没有的）</code>，在里面写上如下代码：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CURSOR;</span><br><span class="line"></span><br><span class="line">Math.lerp = (a, b, n) =&gt; (<span class="number">1</span> - n) * a + n * b;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="variable">getStyle</span> <span class="operator">=</span> (el, attr) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> window.getComputedStyle</span><br><span class="line">            ? window.getComputedStyle(el)[attr]</span><br><span class="line">            : el.currentStyle[attr];</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cursor</span> &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        <span class="built_in">this</span>.pos = &#123;curr: <span class="literal">null</span>, prev: <span class="literal">null</span>&#125;;</span><br><span class="line">        <span class="built_in">this</span>.pt = [];</span><br><span class="line">        <span class="built_in">this</span>.create();</span><br><span class="line">        <span class="built_in">this</span>.init();</span><br><span class="line">        <span class="built_in">this</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    move(left, top) &#123;</span><br><span class="line">        <span class="built_in">this</span>.cursor.style[<span class="string">&quot;left&quot;</span>] = `$&#123;left&#125;px`;</span><br><span class="line">        <span class="built_in">this</span>.cursor.style[<span class="string">&quot;top&quot;</span>] = `$&#123;top&#125;px`;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    create() &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.cursor) &#123;</span><br><span class="line">            <span class="built_in">this</span>.cursor = document.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.cursor.id = <span class="string">&quot;cursor&quot;</span>;</span><br><span class="line">            <span class="built_in">this</span>.cursor.classList.add(<span class="string">&quot;hidden&quot;</span>);</span><br><span class="line">            document.body.append(<span class="built_in">this</span>.cursor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">var</span> <span class="variable">el</span> <span class="operator">=</span> document.getElementsByTagName(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">let</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; el.length; i++)</span><br><span class="line">            <span class="keyword">if</span> (getStyle(el[i], <span class="string">&quot;cursor&quot;</span>) == <span class="string">&quot;pointer&quot;</span>)</span><br><span class="line">                <span class="built_in">this</span>.pt.push(el[i].outerHTML);</span><br><span class="line"></span><br><span class="line">        document.body.appendChild((<span class="built_in">this</span>.scr = document.createElement(<span class="string">&quot;style&quot;</span>)));</span><br><span class="line">        <span class="comment">// 这里改变鼠标指针的颜色 由svg生成</span></span><br><span class="line">        <span class="built_in">this</span>.scr.innerHTML = `* &#123;cursor: url(<span class="string">&quot;data:image/svg+xml,&lt;svg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; viewBox=&#x27;0 0 8 8&#x27; width=&#x27;8px&#x27; height=&#x27;8px&#x27;&gt;&lt;circle cx=&#x27;4&#x27; cy=&#x27;4&#x27; r=&#x27;4&#x27; opacity=&#x27;.5&#x27;/&gt;&lt;/svg&gt;&quot;</span>) <span class="number">4</span> <span class="number">4</span>, auto&#125;`;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    refresh() &#123;</span><br><span class="line">        <span class="built_in">this</span>.scr.remove();</span><br><span class="line">        <span class="built_in">this</span>.cursor.classList.remove(<span class="string">&quot;hover&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.cursor.classList.remove(<span class="string">&quot;active&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.pos = &#123;curr: <span class="literal">null</span>, prev: <span class="literal">null</span>&#125;;</span><br><span class="line">        <span class="built_in">this</span>.pt = [];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.create();</span><br><span class="line">        <span class="built_in">this</span>.init();</span><br><span class="line">        <span class="built_in">this</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init() &#123;</span><br><span class="line">        document.onmouseover  = e =&gt; <span class="built_in">this</span>.pt.includes(e.target.outerHTML) &amp;&amp; <span class="built_in">this</span>.cursor.classList.add(<span class="string">&quot;hover&quot;</span>);</span><br><span class="line">        document.onmouseout   = e =&gt; <span class="built_in">this</span>.pt.includes(e.target.outerHTML) &amp;&amp; <span class="built_in">this</span>.cursor.classList.remove(<span class="string">&quot;hover&quot;</span>);</span><br><span class="line">        document.onmousemove  = e =&gt; &#123;(<span class="built_in">this</span>.pos.curr == <span class="literal">null</span>) &amp;&amp; <span class="built_in">this</span>.move(e.clientX - <span class="number">8</span>, e.clientY - <span class="number">8</span>); <span class="built_in">this</span>.pos.curr = &#123;x: e.clientX - <span class="number">8</span>, y: e.clientY - <span class="number">8</span>&#125;; <span class="built_in">this</span>.cursor.classList.remove(<span class="string">&quot;hidden&quot;</span>);&#125;;</span><br><span class="line">        document.onmouseenter = e =&gt; <span class="built_in">this</span>.cursor.classList.remove(<span class="string">&quot;hidden&quot;</span>);</span><br><span class="line">        document.onmouseleave = e =&gt; <span class="built_in">this</span>.cursor.classList.add(<span class="string">&quot;hidden&quot;</span>);</span><br><span class="line">        document.onmousedown  = e =&gt; <span class="built_in">this</span>.cursor.classList.add(<span class="string">&quot;active&quot;</span>);</span><br><span class="line">        document.onmouseup    = e =&gt; <span class="built_in">this</span>.cursor.classList.remove(<span class="string">&quot;active&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.pos.prev) &#123;</span><br><span class="line">            <span class="built_in">this</span>.pos.prev.x = Math.lerp(<span class="built_in">this</span>.pos.prev.x, <span class="built_in">this</span>.pos.curr.x, <span class="number">0.15</span>);</span><br><span class="line">            <span class="built_in">this</span>.pos.prev.y = Math.lerp(<span class="built_in">this</span>.pos.prev.y, <span class="built_in">this</span>.pos.curr.y, <span class="number">0.15</span>);</span><br><span class="line">            <span class="built_in">this</span>.move(<span class="built_in">this</span>.pos.prev.x, <span class="built_in">this</span>.pos.prev.y);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.pos.prev = <span class="built_in">this</span>.pos.curr;</span><br><span class="line">        &#125;</span><br><span class="line">        requestAnimationFrame(() =&gt; <span class="built_in">this</span>.render());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(() =&gt; &#123;</span><br><span class="line">    CURSOR = <span class="keyword">new</span> <span class="title class_">Cursor</span>();</span><br><span class="line">    <span class="comment">// 需要重新获取列表时，使用 CURSOR.refresh()</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><blockquote><p>其中比较重要的参数就是鼠标的尺寸和颜色，已经在上面的代码中标出，可以自行调节。</p></blockquote><blockquote><p>在<code>[BlogRoot]\source\css\custom.css</code>添加如下代码：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 鼠标样式 */</span></span><br><span class="line">#cursor &#123;</span><br><span class="line">  position: fixed;</span><br><span class="line">  width: 16px;</span><br><span class="line">  height: 16px;</span><br><span class="line">  <span class="comment">/* 这里改变跟随的底色 */</span></span><br><span class="line">  background: <span class="keyword">var</span>(--theme-color);</span><br><span class="line">  border-radius: 8px;</span><br><span class="line">  opacity: <span class="number">0.25</span>;</span><br><span class="line">  z-index: <span class="number">10086</span>;</span><br><span class="line">  pointer-events: none;</span><br><span class="line">  transition: <span class="number">0.</span>2s ease-in-out;</span><br><span class="line">  transition-property: background, opacity, transform;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#cursor.hidden &#123;</span><br><span class="line">  opacity: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#cursor.hover &#123;</span><br><span class="line">  opacity: <span class="number">0.1</span>;</span><br><span class="line">  transform: scale(<span class="number">2.5</span>);</span><br><span class="line">  -webkit-transform: scale(<span class="number">2.5</span>);</span><br><span class="line">  -moz-transform: scale(<span class="number">2.5</span>);</span><br><span class="line">  -ms-transform: scale(<span class="number">2.5</span>);</span><br><span class="line">  -o-transform: scale(<span class="number">2.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#cursor.active &#123;</span><br><span class="line">  opacity: <span class="number">0.5</span>;</span><br><span class="line">  transform: scale(<span class="number">0.5</span>);</span><br><span class="line">  -webkit-transform: scale(<span class="number">0.5</span>);</span><br><span class="line">  -moz-transform: scale(<span class="number">0.5</span>);</span><br><span class="line">  -ms-transform: scale(<span class="number">0.5</span>);</span><br><span class="line">  -o-transform: scale(<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里比较重要的参数就是鼠标跟随的圆形颜色，可以根据自己的喜好进行更改：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#cursor &#123;</span><br><span class="line">  <span class="comment">/* 这里改变跟随的底色 */</span></span><br><span class="line">  background: rgb(<span class="number">57</span>, <span class="number">197</span>, <span class="number">187</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最后在主题配置文件 <code>_config.butterfly.yml</code>文件的<code>inject</code>配置项引入刚刚创建的 <code>css</code>文件和 <code>js</code>文件：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">inject:</span><br><span class="line">  head:</span><br><span class="line">    - &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;/css/custom.css&quot;</span>&gt;</span><br><span class="line">  bottom:</span><br><span class="line">    - &lt;script defer src=<span class="string">&quot;/js/cursor.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>重启项目就能看到效果了</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hexo cl; hexo s</span><br></pre></td></tr></table></figure><h4 id="4-5、Live2D-看板娘"><a href="#4-5、Live2D-看板娘" class="headerlink" title="4.5、Live2D 看板娘"></a>4.5、Live2D 看板娘</h4><blockquote><p>详见：<a href="https://akilar.top/posts/5b8f515f/">Live2d Widget | Akilar の糖果屋</a></p></blockquote><blockquote><p>在 Hexo 根目录<code>[BlogRoot]</code>下打开终端，输入以下指令安装必要插件：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><blockquote><p>打开站点配置文件<code>[BlogRoot]\config.yml</code><br>搜索 live2d,按照如下注释内容指示进行操作。<br>如果没有搜到 live2d 的配置项，就直接把以下内容复制到最底部。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Live2D</span><br><span class="line">## https:<span class="comment">//github.com/EYHN/hexo-helper-live2d</span></span><br><span class="line">live2d:</span><br><span class="line">  enable: <span class="literal">true</span> #开关插件版看板娘</span><br><span class="line">  scriptFrom: local # 默认</span><br><span class="line">  pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径)</span><br><span class="line">  pluginJsPath: lib/ # 脚本文件相对与插件根目录路径</span><br><span class="line">  pluginModelPath: assets/ # 模型文件相对与插件根目录路径</span><br><span class="line">  # scriptFrom: jsdelivr # jsdelivr CDN</span><br><span class="line">  # scriptFrom: unpkg # unpkg CDN</span><br><span class="line">  # scriptFrom: https:<span class="comment">//npm.elemecdn.com/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url</span></span><br><span class="line">  tagMode: <span class="literal">false</span> # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span><br><span class="line">  debug: <span class="literal">false</span> # 调试, 是否在控制台输出日志</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-wanko # npm-<span class="keyword">module</span> <span class="keyword">package</span> name</span><br><span class="line">    # use: wanko # 博客根目录/live2d_models/ 下的目录名</span><br><span class="line">    # use: ./wives/wanko # 相对于博客根目录的路径</span><br><span class="line">    # use: https:<span class="comment">//npm.elemecdn.com/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url</span></span><br><span class="line">  display:</span><br><span class="line">    position: right #控制看板娘位置</span><br><span class="line">    width: <span class="number">150</span> #控制看板娘大小</span><br><span class="line">    height: <span class="number">300</span> #控制看板娘大小</span><br><span class="line">  mobile:</span><br><span class="line">    show: <span class="literal">false</span> # 手机中是否展示</span><br></pre></td></tr></table></figure><blockquote><p>然后重启项目即可浏览效果了</p></blockquote><h4 id="4-6、文章置顶滚动栏"><a href="#4-6、文章置顶滚动栏" class="headerlink" title="4.6、文章置顶滚动栏"></a>4.6、文章置顶滚动栏</h4><blockquote><p>安装插件,在博客根目录<code>[BlogRoot]</code>下打开终端，运行以下指令：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm install hexo-butterfly-swiper --save</span><br></pre></td></tr></table></figure><blockquote><p>在站点配置文件<code>_config.yml</code>或者主题配置文件<code>_config.butterfly.yml</code>中添加：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># hexo-butterfly-swiper</span><br><span class="line"># see https:<span class="comment">//akilar.top/posts/8e1264d1/</span></span><br><span class="line">swiper:</span><br><span class="line">  enable: <span class="literal">true</span> # 开关</span><br><span class="line">  priority: <span class="number">5</span> #过滤器优先权</span><br><span class="line">  enable_page: all # 应用页面</span><br><span class="line">  timemode: date #date/updated</span><br><span class="line">  layout: # 挂载容器类型</span><br><span class="line">    type: id</span><br><span class="line">    name: recent-posts</span><br><span class="line">    index: <span class="number">0</span></span><br><span class="line">  default_descr: 再怎么看我也不知道怎么描述它的啦！</span><br><span class="line">  swiper_css: https:<span class="comment">//npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css #swiper css依赖</span></span><br><span class="line">  swiper_js: https:<span class="comment">//npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js #swiper js依赖</span></span><br><span class="line">  custom_css: https:<span class="comment">//npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css # 适配主题样式补丁</span></span><br><span class="line">  custom_js: https:<span class="comment">//npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js # swiper初始化方法</span></span><br></pre></td></tr></table></figure><blockquote><p>到这里，相信你已经成功搭建了一个外观简洁且漂亮的博客。在这个过程中，我们不仅完成了博客的基础搭建，还通过美化主题让博客的视觉效果更加吸引人。不过，真正让博客与众不同的，不仅仅是它的外观，而是博客的内容。你可以根据自己的兴趣和需求，持续添加有价值的内容，分享你的技术经验、生活感悟或创作成果。</p></blockquote><blockquote><p>无论是记录学习过程中的点滴，还是分享工作中的见解，内容才是吸引读者和展示个人特色的关键。希望你能通过这个平台，不断积累和沉淀，让你的博客成为一个有深度、有温度的地方。</p></blockquote><blockquote><p>最后，博客的搭建只是开始，真正的挑战是如何持续更新内容，并与读者建立连接。祝你在博客的创作之路上越走越远！”</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot + Vue 前后端分离项目上线实记</title>
      <link href="/2025/02/06/Spring%20Boot%20+%20Vue%20%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%E5%AE%9E%E8%AE%B0/"/>
      <url>/2025/02/06/Spring%20Boot%20+%20Vue%20%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%E5%AE%9E%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><blockquote><p>本文记录了一个前后端分离项目的完整部署流程。许多同学在本地开发完项目后，缺乏将其部署到远程服务器的实战经验。因此，我将以一个实际项目为例，详细展示从环境准备到最终上线的全过程，希望对你有所帮助！</p></blockquote><h3 id="二、服务器环境准备"><a href="#二、服务器环境准备" class="headerlink" title="二、服务器环境准备"></a>二、服务器环境准备</h3><h4 id="2-1、配置服务器"><a href="#2-1、配置服务器" class="headerlink" title="2.1、配置服务器"></a>2.1、配置服务器</h4><blockquote><p>首先准备一个服务器，我这里用的是阿里云 ：<br><img src="https://api.smain.cn/pics/pic_36ac480d.png" alt="pic_36ac480d.png"> &gt; <img src="https://api.smain.cn/pics/pic_a538f7f4.png" alt="pic_a538f7f4.png"><br>第一次购买一般都会有优惠，而且对于一般的单体项目而言 2 核 2G 的配置也够用了，当然也有 3 个月的试用版本。<br>完成之后进入控制台第一件事就是去你左侧边栏的安全组里面开放端口，这样才能从远程访问。<br><img src="https://api.smain.cn/pics/pic_bf53d162.png" alt="pic_bf53d162.png"> &gt; <img src="https://api.smain.cn/pics/pic_b1b9b5e1.png" alt="pic_b1b9b5e1.png"><br>端口范围根据需求开放，一般是 3306 mysql、80 nginx 代理、13103 这里是宝塔面板的端口，什么是宝塔面板后面会讲到，下面 3 个端口是默认初始化好的。<br>然后进入实例面板重新设置一下你的服务器密码：<br><img src="https://api.smain.cn/pics/pic_de438d2c.png" alt="pic_de438d2c.png"><br>修改完成之后就可以试着连接你的服务器了，我这里使用的是 Xshell：<br><img src="https://api.smain.cn/pics/pic_49e41dd4.png" alt="pic_49e41dd4.png"><br>然后输入你刚才重新设置的密码并点击连接：<br><img src="https://api.smain.cn/pics/pic_fcbe6fcc.png" alt="pic_fcbe6fcc.png"> &gt; <img src="https://api.smain.cn/pics/pic_ec2b2f8c.png" alt="pic_ec2b2f8c.png"></p></blockquote><h4 id="2-2、安装所需环境"><a href="#2-2、安装所需环境" class="headerlink" title="2.2、安装所需环境"></a>2.2、安装所需环境</h4><blockquote><p>成功连接好了服务器之后根据你的项目分析一下所要安装的环境</p><ul><li>jdk</li><li>Mysql、Redis</li><li>Nginx<br>这里我们使用宝塔面板来管理我们的 Linux 服务器：<br><img src="https://api.smain.cn/pics/pic_f4dcaa3e.png" alt="pic_f4dcaa3e.png"><br>直接复制代码贴到 Xshell 执行即可：</li></ul></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -f /usr/bin/curl ];then curl -sSO https:<span class="comment">//download.bt.cn/install/install_panel.sh;else wget -O install_panel.sh https://download.bt.cn/install/install_panel.sh;fi;bash install_panel.sh ed8484bec</span></span><br></pre></td></tr></table></figure><blockquote><p>安装好后会出现外网地址和用户名和密码，打开外网地址后就能看到宝塔登录界面。<br><img src="https://api.smain.cn/pics/pic_069feb0c.png" alt="pic_069feb0c.png"> &gt; <img src="https://api.smain.cn/pics/pic_3fe1aeb7.png" alt="pic_3fe1aeb7.png"><br>如果访问不通就是你没有放行端口，进入阿里云安全组里面去放行对应的端口即可。<br>进入控制面板后直接在右下角的软件商店中安装所需环境：<br><img src="https://api.smain.cn/pics/pic_245b2680.png" alt="pic_245b2680.png"><br>点开首页就可以清楚的看到我们服务器的整体情况了：<br><img src="https://api.smain.cn/pics/pic_62011a33.png" alt="pic_62011a33.png"></p></blockquote><h3 id="三、后端部署"><a href="#三、后端部署" class="headerlink" title="三、后端部署"></a>三、后端部署</h3><h4 id="3-1、项目打包"><a href="#3-1、项目打包" class="headerlink" title="3.1、项目打包"></a>3.1、项目打包</h4><blockquote><p>基于 Spring Boot + Vue 的前后端分离项目，主要有两种部署方式：</p><ol><li>前后端一起部署</li></ol><p>这种方式将 Vue 项目打包后的 <code>dist</code> 目录放入 Spring Boot 项目的资源目录（如 <code>src/main/resources/static</code>），然后直接部署 Spring Boot 项目。实质上，前端文件仍然由后端的 Tomcat 服务器提供，并不是真正的前后端分离。</p><ul><li>优点：部署简单，无需额外的跨域配置。</li><li>缺点：如果项目较大，会给 Tomcat 服务器带来较大压力，影响响应速度，且不利于前后端分工协作。</li></ul><ol start="2"><li>前后端单独部署（推荐）</li></ol><p>在这种方式下，Spring Boot 项目和 Vue 项目分别独立部署：</p><ul><li>后端：Spring Boot 项目打包后运行，使用内嵌 Tomcat 提供 API 服务。</li><li>前端：Vue 项目打包后交由 Nginx 运行。</li><li>请求处理：Nginx 负责端口转发，解决跨域问题，使前端能正常访问后端接口。</li></ul><p>相比第一种方式，这种方式稍微复杂一些，但更符合前后端分离架构，能够减少后端服务器压力，提高系统性能。<br>本文将介绍 第二种方式 的部署流程，并通过 宝塔面板 进行可视化部署。正式开始之前，需要先确保环境就绪。<br>在对后端项目进行打包之前还需要做一些修改，如果你的配置文件不是动态加载的话那就去修改一下你的数据库连接配置：<br><img src="https://api.smain.cn/pics/pic_ce9a5037.png" alt="pic_ce9a5037.png"><br>然后将可以进行打包部署了，在你父模块（如果是聚合工程的话）的 lifecycle 下先运行 clean 再运行 package 进行打包：<br><img src="https://api.smain.cn/pics/pic_7ce2144b.png" alt="pic_7ce2144b.png"><br>打包完成后会在你的 target 目录下生成对应的.jar 包，然后将其上传到服务器上。</p></blockquote><h4 id="3-2、创建数据库"><a href="#3-2、创建数据库" class="headerlink" title="3.2、创建数据库"></a>3.2、创建数据库</h4><blockquote><p>在宝塔面板中创建数据库并导入 sql 脚本：<br><img src="https://api.smain.cn/pics/pic_a3d484a1.png" alt="pic_a3d484a1.png"> &gt; <img src="https://api.smain.cn/pics/pic_59f04fa9.png" alt="pic_59f04fa9.png"><br>在你的数据库根目录下启动终端运行下面一段代码即可将当前数据库的数据导出为.sql 脚本：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mysqldump -u username -p database_name &gt; /path/to/backup.sql</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>-u username</code>：指定数据库用户名。</li><li><code>-p</code>：提示输入数据库密码。</li><li><code>database_name</code>：要导出的数据库名。</li><li><code>/path/to/backup.sql</code>：备份文件保存的路径。<br>运行后会提示你输入数据库密码，完成后即可成功导出。<br><img src="https://api.smain.cn/pics/pic_b342acd5.png" alt="pic_b342acd5.png"></li></ul></blockquote><h4 id="3-3、测试启动"><a href="#3-3、测试启动" class="headerlink" title="3.3、测试启动"></a>3.3、测试启动</h4><blockquote><p>数据库建好后就可以去启动你的后端服务看一下是否成功了</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nohup java -jar 你的项目.jar --server.port=<span class="number">8080</span> &gt; app.log <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p><code>nohup</code> 是一个 Linux 命令，意思是 “no hangup”，它用来在退出终端后继续运行命令。通常，命令在终端关闭时会终止，但使用 <code>nohup</code> 后，即使关闭终端，程序依然会继续运行。</p></li><li><p><code>--server.port=8080</code>：指定应用程序的 HTTP 服务端口为 <code>8080</code>，默认情况下 Spring Boot 应用会监听 <code>8080</code> 端口，但可以通过该参数修改端口。</p></li><li><p><code>&gt; app.log</code>：<br>这是将标准输出（stdout）重定向到文件 <code>app.log</code> 中。</p><p><code>&gt;</code> 是重定向符号，它会把命令的输出写入到指定文件中，如果文件不存在会自动创建。<code>app.log</code> 是输出日志文件的名称，这里创建一下日志文件方便调试。</p></li><li><p><code>&amp;</code>：这个符号将命令放到后台运行。</p><p>在命令末尾加 <code>&amp;</code> 可以使该命令在后台运行，不会阻塞当前终端。你可以继续在终端中进行其他操作。<br><img src="https://api.smain.cn/pics/pic_623b9a15.png" alt="pic_623b9a15.png"><br>ok 没有问题，下面进入前端部署。</p></li></ul></blockquote><h3 id="四、前端部署"><a href="#四、前端部署" class="headerlink" title="四、前端部署"></a>四、前端部署</h3><h4 id="4-1、项目打包"><a href="#4-1、项目打包" class="headerlink" title="4.1、项目打包"></a>4.1、项目打包</h4><blockquote><p>在前端终端输入以下命令进行打包：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><blockquote><p>具体情况可以结合你自己 package.json 文件里面的设置执行：<br><img src="https://api.smain.cn/pics/pic_b154a0f8.png" alt="pic_b154a0f8.png"><br>打包完成后会在你项目的第一级目录下生成 dist 文件夹：<br><img src="https://api.smain.cn/pics/pic_2d2b56c0.png" alt="pic_2d2b56c0.png"><br>然后将这个文件夹上传到服务器，我个人的习惯是和后端 jar 包放在一起：<br><img src="https://api.smain.cn/pics/pic_610287b2.png" alt="pic_610287b2.png"></p></blockquote><h4 id="4-2、nginx-配置"><a href="#4-2、nginx-配置" class="headerlink" title="4.2、nginx 配置"></a>4.2、nginx 配置</h4><blockquote><p>为了让前端和后端的请求能够正确地通过 Nginx 进行转发，我们需要配置 Nginx 实现反向代理。具体配置如下：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 处理 RyVending 项目的前端请求</span><br><span class="line">      server &#123;</span><br><span class="line">        listen       <span class="number">80</span>;</span><br><span class="line">        server_name  你的服务器ip地址;</span><br><span class="line">            charset utf-<span class="number">8</span>;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /www/wwwroot/RyVending/dist（你的dist文件的目录）;</span><br><span class="line">                  try_files $uri $uri/ /index.html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        location /prod-api/（你自己的路由） &#123;</span><br><span class="line">            proxy_set_header Host $http_host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_pass http:<span class="comment">//localhost:8080/;</span></span><br><span class="line">        &#125;</span><br><span class="line">        error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>location /</code>：这个 <code>location</code> 块用于处理所有指向根路径 <code>/</code> 的请求，通常是前端页面的访问。</li><li><code>root /www/wwwroot/RyVending/dist;</code>：指定 Vue 前端打包后的静态文件所在的目录，这里是 <code>dist</code> 目录。<code>dist</code> 目录是 Vue 打包后的输出目录，包含所有 HTML、CSS、JS 文件。</li><li><code>try_files $uri $uri/ /index.html;</code>：这是为了支持 Vue 的前端路由。如果用户直接刷新页面或访问子路由，Nginx 会先尝试查找具体的文件或目录。如果找不到，则返回 <code>index.html</code>，从而让 Vue 路由控制页面显示。</li><li><code>location /prod-api/</code>：这个块用于处理所有以 <code>/prod-api/</code> 开头的请求，将其转发到后端的 Spring Boot 应用。这里的 <code>/prod-api/</code> 是你自定义的后端 API 路径前缀，可以根据你的需要修改。</li><li><code>proxy_set_header Host $http_host;</code>：将客户端请求的 <code>Host</code> 头部转发给后端服务器，这样后端应用就能知道真实的主机名。</li><li><code>proxy_set_header X-Real-IP $remote_addr;</code>：将客户端的真实 IP 地址传递给后端应用，通常用于日志记录或安全检查。</li><li><code>proxy_set_header REMOTE-HOST $remote_addr;</code>：这个设置也用于传递客户端的 IP 地址（与 <code>X-Real-IP</code> 类似）。</li><li><code>proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</code>：这个设置会将客户端的真实 IP 添加到 <code>X-Forwarded-For</code> 头中，它可以帮助后端应用识别经过反向代理的真实请求来源。</li><li><code>proxy_pass http://localhost:8080/;</code>：这是反向代理指令，表示将所有请求转发到本地的 <code>8080</code> 端口（即后端的 Spring Boot 服务）。你可以根据需要修改端口或地址。<br>到此所有步骤都完成了，赶紧去浏览器访问你的项目吧！</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud 微服务入门：服务调用流程解析</title>
      <link href="/2025/01/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%EF%BC%9A%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/"/>
      <url>/2025/01/25/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%EF%BC%9A%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>目录</p><p><a href="#%E4%B8%80%E3%80%81%E5%BC%95%E8%A8%80">1、引言</a></p><p><a href="#%E4%BA%8C%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5">2、微服务基础概念</a></p><p><a href="#2.1%E3%80%81%E6%A1%86%E6%9E%B6%E6%80%BB%E8%A7%88">2.1、框架总览</a></p><p><a href="#2.2%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E7%9A%84%E5%AF%B9%E6%AF%94">2.2、微服务与单体架构的对比</a></p><p><a href="#%E4%B8%89%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9C%80%E5%A4%A7%E7%89%B9%E7%82%B9%EF%BC%9A%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E7%94%A8">3、微服务的最大特点：服务之间的调用</a></p><p><a href="#3.1%E3%80%81%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C">3.1、服务注册</a></p><p><a href="#3.1.1%E3%80%81%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86">3.1.1、注册中心原理</a></p><p><a href="#3.1.2%E3%80%81Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83">3.1.2、Nacos 注册中心</a></p><p><a href="#3.1.3%E3%80%81%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C">3.1.3、服务注册</a></p><p><a href="#3.2%E3%80%81%E6%9C%8D%E5%8A%A1%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F">3.2、服务间通信方式</a></p><p><a href="#3.2.1%E3%80%81OpenFeign">3.2.1、OpenFeign</a></p><p><a href="#3.2.2%E3%80%81RabbitMQ">3.2.2、RabbitMQ</a></p><p><a href="#3.2.3%E3%80%81SpringAMQP">3.2.3、SpringAMQP</a></p><p><a href="#3.3%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">3.3、负载均衡</a></p><p><a href="#3.3.1%E3%80%81%E6%BA%90%E7%A0%81%E8%B7%9F%E8%B8%AA">3.3.1、源码跟踪</a></p><p><a href="#3.3.2%E3%80%81NacosRule">3.3.2、NacosRule</a></p><p><a href="#3.4%E3%80%81%C2%A0%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99%E6%9C%BA%E5%88%B6">3.4、 服务容错机制</a></p><p><a href="#3.4.1%E3%80%81%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4%E6%96%B9%E6%A1%88">3.4.1、服务保护方案</a></p><p><a href="#3.4.2%E3%80%81Sentinel">3.4.2、Sentinel</a></p><p><a href="#3.4.3%E3%80%81%E8%AF%B7%E6%B1%82%E9%99%90%E6%B5%81">3.4.3、请求限流</a></p><p><a href="#3.4.4%E3%80%81%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB">3.4.4、线程隔离</a></p><p><a href="#3.4.5%E3%80%81%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD">3.4.5、服务熔断</a></p><p><a href="#3.5%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1">3.5、分布式事务</a></p><p><a href="#3.5.1%E3%80%81Seata">3.5.1、Seata</a></p><p><a href="#3.5.2%E3%80%81XA%E6%A8%A1%E5%BC%8F">3.5.2、XA 模式</a></p><p><a href="#3.5.3%E3%80%81AT%E6%A8%A1%E5%BC%8F">3.5.3、AT 模式</a></p><p><a href="#%E5%9B%9B%E3%80%81%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA%EF%BC%9A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B">4、案例演示：微服务调用的完整流程</a></p><p><a href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93">5、结语</a></p><h2 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h2><blockquote><p>在当今的软件开发领域，微服务架构已经成为一种热门的设计模式。与传统的单体架构相比，微服务架构通过将系统拆分为多个小而独立的服务，使得开发、部署和维护变得更加灵活。这种架构设计不仅能够适应现代互联网应用的快速变化需求，还能在一定程度上缓解开发团队之间的协作冲突。<br>但同时，微服务也引入了许多新的挑战，其中最核心的一个问题就是服务之间的相互调用。在单体架构中，模块之间的调用通常是本地方法的调用，简单而高效。而在微服务架构中，不同服务运行在独立的进程中，甚至可能分布在不同的服务器上，服务之间的通信需要通过网络来实现，这无疑增加了复杂性。<br>在这篇文章中，我们将围绕微服务架构的基础概念展开，重点探讨其与单体项目的主要不同点，尤其是服务之间的调用逻辑。通过一个简单的案例，我们会展示 SpringCloud 框架下服务调用的完整流程，帮助你快速理解微服务。</p></blockquote><h2 id="2、微服务基础概念"><a href="#2、微服务基础概念" class="headerlink" title="2、微服务基础概念"></a>2、微服务基础概念</h2><h3 id="2-1、框架总览"><a href="#2-1、框架总览" class="headerlink" title="2.1、框架总览"></a>2.1、框架总览</h3><blockquote><p>首先要了解什么是微服务就需要对其整体框架有一个全局的概念，下面这张概述图详细的展示了微服务的大体框架：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_6c17275f.png" alt="pic_6c17275f.png"></p><blockquote><p>可以发现微服务涉及的相关组件还是蛮多的，相较于单体项目终端直接与数据库相连，中间最多加个网关，微服务由于其服务之间的隔离性，导致其相互调用成了一个比较麻烦的问题，随之而来的还有一大堆分布式事务相关的安全问题。</p></blockquote><blockquote><p>本文主要对控制面、治理面和数据面进行讲解，涉及到的组件有：</p><ul><li>Nacos</li><li>Sentinel</li><li>GateWay 网关</li><li>OpenFeign</li><li>RabbitMQ</li></ul></blockquote><h3 id="2-2、微服务与单体架构的对比"><a href="#2-2、微服务与单体架构的对比" class="headerlink" title="2.2、微服务与单体架构的对比"></a>2.2、微服务与单体架构的对比</h3><table>  <tbody>   <tr>    <td>特性</td>    <td>单体架构</td>    <td>微服务架构</td>   </tr>   <tr>    <td>开发</td>    <td>所有模块集中在一个代码库中，协作紧密</td>    <td>各模块独立开发，松耦合</td>   </tr>   <tr>    <td>部署</td>    <td>整体部署，一次更新影响整个系统</td>    <td>独立部署，每个服务可以单独更新</td>   </tr>   <tr>    <td>扩展</td>    <td>水平扩展整个应用，浪费资源</td>    <td>精确扩展特定服务，资源利用率更高</td>   </tr>   <tr>    <td>技术栈</td>    <td>单一技术栈，统一性强</td>    <td>多样化技术栈，根据服务需求灵活选择</td>   </tr>  </tbody> </table><h2 id="3、微服务的最大特点：服务之间的调用"><a href="#3、微服务的最大特点：服务之间的调用" class="headerlink" title="3、微服务的最大特点：服务之间的调用"></a>3、微服务的最大特点：服务之间的调用</h2><blockquote><p>在微服务架构中，服务之间的调用是系统运行的核心，也是微服务架构与单体架构最大的区别之一。由于服务运行在不同的进程中，甚至分布在不同的服务器上，其通信方式需要考虑网络传输的复杂性。以下是微服务调用的几个关键要素以及相关组件：</p></blockquote><h3 id="3-1、服务注册"><a href="#3-1、服务注册" class="headerlink" title="3.1、服务注册"></a>3.1、服务注册</h3><blockquote><p>在微服务架构中，每个服务可能动态变化（如启动、关闭或迁移）。为了实现服务之间的通信，首先需要一个机制来注册和发现服务。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_ee9bc610.png" alt="pic_ee9bc610.png"></p><h4 id="3-1-1、注册中心原理"><a href="#3-1-1、注册中心原理" class="headerlink" title="3.1.1、注册中心原理"></a>3.1.1、注册中心原理</h4><blockquote><p>举个例子，在微服务远程调用的过程中，包括两个角色：</p><ul><li>服务提供者：提供接口供其它微服务访问，比如 <code>item-service</code></li><li>服务消费者：调用其它微服务提供的接口，比如 <code>cart-service</code></li></ul></blockquote><blockquote><p>在大型微服务项目中，服务提供者的数量会非常多，为了管理这些服务就引入了注册中心的概念。注册中心、服务提供者、服务消费者三者间关系如下：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_e4133fd6.png" alt="pic_e4133fd6.png"></p><blockquote><p>流程如下：</p><ul><li>服务启动时就会注册自己的服务信息（服务名、IP、端口）到注册中心</li><li>调用者可以从注册中心订阅想要的服务，获取服务对应的实例列表（1 个服务可能多实例部署）</li><li>调用者自己对实例列表负载均衡，挑选一个实例</li><li>调用者向该实例发起远程调用</li></ul></blockquote><blockquote><p>当服务提供者的实例宕机或者启动新实例时，调用者如何得知呢？</p><ul><li>服务提供者会定期向注册中心发送请求，报告自己的健康状态（心跳请求）</li><li>当注册中心长时间收不到提供者的心跳时，会认为该实例宕机，将其从服务的实例列表中剔除</li><li>当服务有新实例启动时，会发送注册服务请求，其信息会被记录在注册中心的服务实例列表</li><li>当注册中心服务列表变更时，会主动通知微服务，更新本地服务列表</li></ul></blockquote><h4 id="3-1-2、Nacos-注册中心"><a href="#3-1-2、Nacos-注册中心" class="headerlink" title="3.1.2、Nacos 注册中心"></a>3.1.2、Nacos 注册中心</h4><blockquote><p>目前开源的注册中心框架有很多，国内比较常见的有：</p><ul><li>Eureka：Netflix 公司出品，目前被集成在 SpringCloud 当中，一般用于 Java 应用</li><li>Nacos：Alibaba 公司出品，目前被集成在 SpringCloudAlibaba 中，一般用于 Java 应用</li><li>Consul：HashiCorp 公司出品，目前集成在 SpringCloud 中，不限制微服务语言</li></ul></blockquote><blockquote><p>由于 Nacos 是国内产品，中文文档比较丰富，而且同时具备配置管理功能，所以使用较多。下面来讲一下怎么部署 Nacos，推荐是使用 linux 虚拟机结合 docker 来进行部署，这里就不详细演示怎么安装 docker 了，有需要的可以去看一下我之前写的博客，这里就直接参考 Nacos 官网进行安装：</p></blockquote><p><a href="https://nacos.io/docs/latest/quickstart/quick-start">Nacos 快速开始 | Nacos 官网这个快速开始手册是帮忙您快速在您的电脑上，下载、安装并使用 Nacos。https://nacos.io/docs/latest/quickstart/quick-start<img src="https://api.smain.cn/pics/pic_6feeb0fa.png" alt="pic_6feeb0fa.png">https://nacos.io/docs/latest/quickstart/quick-start</a><img src="https://api.smain.cn/pics/pic_e8d7d828.png" alt="pic_e8d7d828.png"></p><p>解压到非中文路径下：</p><p><img src="https://api.smain.cn/pics/pic_397574c9.png" alt="pic_397574c9.png"></p><p><img src="https://api.smain.cn/pics/pic_1dbd4962.png" alt="pic_1dbd4962.png"></p><p>打开编辑，在开头处加入如下内容:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 1999-2018 Alibaba Group Holding Ltd.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> # 以下内容需手动加入</span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> `nacos_config`;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE `nacos_config` <span class="keyword">DEFAULT</span> <span class="keyword">character set</span> utf8mb4;</span><br><span class="line"><span class="keyword">SET</span> names utf8mb4;</span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">USE `nacos_config`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br></pre></td></tr></table></figure><p>然后打开你的数据库将脚本导入创建 nacos 数据库：</p><p><img src="https://api.smain.cn/pics/pic_06de63c9.png" alt="pic_06de63c9.png"></p><p>修改数据库连接默认配置：</p><p><img src="https://api.smain.cn/pics/pic_28c31890.png" alt="pic_28c31890.png"></p><p><img src="https://api.smain.cn/pics/pic_a698e5e1.png" alt="pic_a698e5e1.png"></p><p>启动后访问 localhost:8848&#x2F;nacos ：</p><p><img src="https://api.smain.cn/pics/pic_98c3381a.png" alt="pic_98c3381a.png"></p><h4 id="3-1-3、服务注册"><a href="#3-1-3、服务注册" class="headerlink" title="3.1.3、服务注册"></a>3.1.3、服务注册</h4><blockquote><p>接下来就是在你的项目中添加依赖并进行配置：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--nacos 服务注册发现--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: item-service # 服务名称</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8848</span> # nacos地址</span><br></pre></td></tr></table></figure><p><img src="https://api.smain.cn/pics/pic_6b15c275.png" alt="pic_6b15c275.png"></p><h3 id="3-2、服务间通信方式"><a href="#3-2、服务间通信方式" class="headerlink" title="3.2、服务间通信方式"></a>3.2、服务间通信方式</h3><blockquote><p>微服务之间的通信主要有以下两种方式：</p><ul><li>同步调用（HTTP REST）：使用轻量级的 HTTP 协议，适合请求-响应模式。SpringCloud 提供了 OpenFeign 组件用于简化 REST 调用，通过声明式接口实现服务间的远程调用。</li><li>异步调用（消息队列）：通过消息中间件实现异步通信和解耦，适合事件驱动的场景。RabbitMQ：一个流行的开源消息队列，支持 AMQP 协议，具有高性能、可靠性和灵活性，常用于实现微服务间的异步通信和事件通知。</li></ul></blockquote><h4 id="3-2-1、OpenFeign"><a href="#3-2-1、OpenFeign" class="headerlink" title="3.2.1、OpenFeign"></a>3.2.1、OpenFeign</h4><blockquote><p>其实远程调用的关键点就在于四个：</p><ol><li>请求方式</li><li>请求路径</li><li>请求参数</li><li>返回值类型</li></ol></blockquote><blockquote><p>所以，OpenFeign 就利用 SpringMVC 的相关注解来声明上述 4 个参数，然后基于动态代理帮我们生成远程调用的代码，而无需我们手动再编写，非常方便。</p><p>需要注意的是，调用方也要像刚才那样引入 nacos 依赖并进行配置，接下来，我们就通过一个快速入门的案例来体验一下 OpenFeign 的便捷吧。</p></blockquote><p>首先还是在调用方引入依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--openFeign--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;!--负载均衡器--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意这里服务之间的调用涉及到了负载均衡，所以也要把 loadbalancer 的依赖也引入，关于负载均衡的讲解放到了后面。</p></blockquote><p>在调用者的启动类上添加注解，启动 OpenFeign 功能：</p><p><img src="https://api.smain.cn/pics/pic_c4a34833.png" alt="pic_c4a34833.png"></p><p>然后新建一个 client 包，里面放访问客户端：</p><p><img src="https://api.smain.cn/pics/pic_6c587f75.png" alt="pic_6c587f75.png"></p><blockquote><p>这里只需要声明接口，无需实现方法，因为 OpenFeign 基于 Nacos 的远程调用原理是 声明式 HTTP 调用 + 动态服务发现，通过动态代理、Nacos 的服务注册与发现，以及负载均衡等机制实现服务之间的无缝通信。具体流程后面会讲到。</p></blockquote><blockquote><p>接口中的几个关键信息：</p><ul><li>@FeignClient(“item-service”) ：声明服务名称</li><li>@GetMapping ：声明请求方式</li><li>@GetMapping(“&#x2F;items”) ：声明请求路径</li><li>@RequestParam(“ids”) Collection<Long> ids ：声明请求参数</li><li>List<ItemDTO> ：返回值类型</li></ul><p>有了上述信息，OpenFeign 就可以利用动态代理帮我们实现这个方法，并且向 <a href="http://item-service/items">http://item-service/items</a> 发送一个 GET 请求，携带 ids 为请求参数，并自动将返回值处理为 List<ItemDTO>。</p><p>我们只需要直接调用这个方法，即可实现远程调用了。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_53b9572b.png" alt="pic_53b9572b.png"></p><p><img src="https://api.smain.cn/pics/pic_aee1db5c.png" alt="pic_aee1db5c.png"></p><blockquote><p>当然涉及到多线程必然要考虑性能的问题，OpenFeign 也支持线程池，在调用者端引入依赖并进行配置即可生效还是非常方便的。</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#.xml</span><br><span class="line"><span class="comment">&lt;!--OK http 的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#.yaml</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启OKHttp功能</span></span><br></pre></td></tr></table></figure><h4 id="3-2-2、RabbitMQ"><a href="#3-2-2、RabbitMQ" class="headerlink" title="3.2.2、RabbitMQ"></a>3.2.2、RabbitMQ</h4><blockquote><p>前面我们了解了同步调用，在讲解异步调用之前，首先还是来看一下它们各自的优缺点：</p></blockquote><table>  <tbody>   <tr>    <td>特性</td>    <td>同步调用</td>    <td>异步调用</td>   </tr>   <tr>    <td>定义</td>    <td>调用方发出请求后会等待响应完成，才能继续执行后续逻辑。</td>    <td>调用方发出请求后无需等待响应，可立即继续执行其他任务。</td>   </tr>   <tr>    <td>通信协议</td>    <td>通常基于 HTTP 或 RPC</td>    <td>通常基于消息队列（如 RabbitMQ、Kafka 等）。</td>   </tr>   <tr>    <td>耦合度</td>    <td>服务间紧密耦合，调用方需要直接知道服务提供方的信息。</td>    <td>服务间松耦合，通过消息中间件解耦。</td>   </tr>   <tr>    <td>实时性</td>    <td>响应实时性高，适合对结果有即时需求的场景。</td>    <td>延迟容忍度高，适合对结果实时性要求不高的场景。</td>   </tr>   <tr>    <td>可靠性</td>    <td>如果服务不可用，调用会失败，需要结合重试机制或熔断处理。</td>    <td>消息通常持久化存储，可靠性高，即使目标服务暂时不可用，消息不会丢失。</td>   </tr>  </tbody> </table><p><img src="https://api.smain.cn/pics/pic_2b9a1a0f.png" alt="pic_2b9a1a0f.png"></p><p><img src="https://api.smain.cn/pics/pic_4b9baabb.png" alt="pic_4b9baabb.png"></p><blockquote><p>异步调用方式其实就是基于消息通知的方式，一般包含三个角色：</p><ol><li>消息发送者：投递消息的人，就是原来的调用方</li><li>消息 Broker：管理、暂存、转发消息，你可以把它理解成微信服务器</li><li>消息接收者：接收和处理消息的人，就是原来的服务提供方</li></ol></blockquote><p><img src="https://api.smain.cn/pics/pic_1c3d2652.png" alt="pic_1c3d2652.png"></p><blockquote><p>在异步调用中，发送者不再直接同步调用接收者的业务接口，而是发送一条消息投递给消息 Broker。然后接收者根据自己的需求从消息 Broker 那里订阅消息。每当发送方发送消息后，接受者都能获取消息并处理。这样，发送消息的人和接收消息的人就完全解耦了。</p></blockquote><blockquote><p>核心思想就是只将关键服务同步调用，而其他一些不太重要的就交给 Broker 异步调用！</p></blockquote><blockquote><p>当然，异步通信也并非完美无缺，它存在下列缺点：</p><ul><li>完全依赖于 Broker 的可靠性、安全性和性能</li><li>架构复杂，后期维护和调试麻烦</li></ul></blockquote><blockquote><p>安装过程这里就不演示了，推荐使用 docker 容器隔离环境，登录后界面如图：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_0b08feb6.png" alt="pic_0b08feb6.png"></p><p>RabbitMQ 对应的架构如图：</p><p><img src="https://api.smain.cn/pics/pic_b98c3ace.png" alt="pic_b98c3ace.png"></p><blockquote><p>其中包含几个概念：</p><ul><li>publisher：生产者，也就是发送消息的一方</li><li>consumer：消费者，也就是消费消息的一方</li><li>queue：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li>exchange：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。</li><li>virtual host：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的 exchange、queue(有点像 mysql 里的 database，不同的项目的 database 相互隔离)</li></ul><p>上述这些东西都可以在 RabbitMQ 的管理控制台来管理.</p></blockquote><blockquote><p>其中交换机和队列要建立绑定关系后才能传递信息，这个时候如果有消费者监听了 MQ 的队列，自然就能收到消息了。</p></blockquote><h4 id="3-2-3、SpringAMQP"><a href="#3-2-3、SpringAMQP" class="headerlink" title="3.2.3、SpringAMQP"></a>3.2.3、SpringAMQP</h4><blockquote><p>将来我们开发业务功能的时候，肯定不会在控制台收发消息，而是应该基于编程的方式。由于 RabbitMQ 采用了 AMQP 协议，因此它具备跨语言的特性。任何语言只要遵循 AMQP 协议收发消息，都可以与 RabbitMQ 交互。并且 RabbitMQ 官方也提供了各种不同语言的客户端。</p><p>但是，RabbitMQ 官方提供的 Java 客户端编码相对复杂，一般生产环境下我们更多会结合 Spring 来使用。而 Spring 的官方刚好基于 RabbitMQ 提供了这样一套消息收发的模板工具：SpringAMQP。并且还基于 SpringBoot 对其实现了自动装配，使用起来非常方便。</p></blockquote><blockquote><p>SpringAMQP 提供了三个功能：</p><ol><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了 RabbitTemplate 工具，用于发送消息</li></ol></blockquote><p>SpringAMQP 如何收发消息？</p><p>1、引入 spring-boot-starter-amqp 依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、配置 rabbitmq 服务端信息</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.36</span><span class="number">.8</span> <span class="comment"># 你的虚拟机IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/hmall</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">test</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>3、利用 RabbitTemplate 发送消息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimpleQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>4、利用@RabbitListener 注解声明要监听的队列，监听消息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用RabbitListener来声明要监听的队列信息</span></span><br><span class="line">    <span class="comment">// 将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。</span></span><br><span class="line">    <span class="comment">// 可以看到方法体中接收的就是消息体的内容</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://api.smain.cn/pics/pic_62994edd.png" alt="pic_62994edd.png"></p><blockquote><p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用 work 模型，多个消费者共同处理消息处理，消息处理的速度就能大大提高了，简单来说就是让多个消费者绑定到一个队列，共同消费队列中的消息。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_94df481c.png" alt="pic_94df481c.png"></p><blockquote><p>交换机的类型有很多其特点也是各不相同，不仅如此关于 RabbitMQ 还有很多的内容，像如何确保 MQ 消息的可靠性，以及消息发送失败后的处理方案和延迟消息，这里就不详细展开了。</p></blockquote><h3 id="3-3、负载均衡"><a href="#3-3、负载均衡" class="headerlink" title="3.3、负载均衡"></a>3.3、负载均衡</h3><blockquote><p>我们知道微服务间远程同步调用都是由 OpenFeign 帮我们完成的，甚至帮我们实现了服务列表之间的负载均衡。但具体负载均衡的规则是什么呢？何时做的负载均衡呢？</p><p>接下来我们一起来分析一下。</p></blockquote><h4 id="3-3-1、源码跟踪"><a href="#3-3-1、源码跟踪" class="headerlink" title="3.3.1、源码跟踪"></a>3.3.1、源码跟踪</h4><p>首先来梳理一下远程调用的步骤：</p><p><img src="https://api.smain.cn/pics/pic_5cf6fee9.png" alt="pic_5cf6fee9.png"></p><p>整体流程如下图所示：</p><p><img src="https://api.smain.cn/pics/pic_4f5eba2e.png" alt="pic_4f5eba2e.png"></p><blockquote><p>可以看到 <code>FeignBlockingLoadBalancerClient</code> 是一个适配器，内部使用了 <code>LoadBalancerClient</code> 来实现服务实例的选择和请求的负载均衡处理。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_1e244f9f.png" alt="pic_1e244f9f.png"></p><p>我们跟进去发现 <code>LoadBalancerClient 接口</code>只有一个实现类就是 BlockingLoadBalancerClient：</p><p><img src="https://api.smain.cn/pics/pic_855654a2.png" alt="pic_855654a2.png"></p><p>其中的 choose 方法实现了负载均衡：</p><p><img src="https://api.smain.cn/pics/pic_185d4835.png" alt="pic_185d4835.png"></p><p>我们继续跟进：</p><p><img src="https://api.smain.cn/pics/pic_45dbc134.png" alt="pic_45dbc134.png"></p><blockquote><p>ReactiveLoadBalancer 是 Spring-Cloud-Common 组件中定义的负载均衡器接口规范，而 Spring-Cloud-Loadbalancer 组件给出了两个实现：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_a9d3ab98.png" alt="pic_a9d3ab98.png"></p><p>默认的实现是 RoundRobinLoadBalancer，即轮询负载均衡器。负载均衡器的核心逻辑如下：</p><p><img src="https://api.smain.cn/pics/pic_a7f74d43.png" alt="pic_a7f74d43.png"></p><p>这里的 ServiceInstanceListSupplier（服务拉取）也有很多实现：</p><p><img src="https://api.smain.cn/pics/pic_227eaadd.png" alt="pic_227eaadd.png"></p><blockquote><p>其中 CachingServiceInstanceListSupplier 采用了装饰模式，加了服务实例列表缓存，避免每次都要去注册中心拉取服务实例列表。而其内部是基于<code>DiscoveryClientServiceInstanceListSupplier</code>来实现的。</p><p>在这个类的构造函数中，就会异步的基于 DiscoveryClient 去拉取服务的实例列表：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_3f787f7a.png" alt="pic_3f787f7a.png"></p><h4 id="3-3-2、NacosRule"><a href="#3-3-2、NacosRule" class="headerlink" title="3.3.2、NacosRule"></a>3.3.2、NacosRule</h4><blockquote><p>之前分析源码的时候我们发现负载均衡的算法是有<code>ReactiveLoadBalancer</code>来定义的，我们发现它的实现类有三个：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_bb776c1b.png" alt="pic_bb776c1b.png"></p><blockquote><p>其中<code>RoundRobinLoadBalancer</code>和<code>RandomLoadBalancer</code>是由<code>Spring-Cloud-Loadbalancer</code>模块提供的，而<code>NacosLoadBalancer</code>则是由<code>Nacos-Discorvery</code>模块提供的。</p><p>默认采用的负载均衡策略是<code>RoundRobinLoadBalancer</code>，那如果我们要切换负载均衡策略该怎么办？</p></blockquote><p>查看源码会发现，<code>Spring-Cloud-Loadbalancer</code>模块中有一个自动配置类：</p><p><img src="https://api.smain.cn/pics/pic_f17d0a34.png" alt="pic_f17d0a34.png"></p><p>其中定义了默认的负载均衡器：</p><p><img src="https://api.smain.cn/pics/pic_3d5b50d2.png" alt="pic_3d5b50d2.png"></p><blockquote><p>这个 Bean 上添加了<code>@ConditionalOnMissingBean</code>注解，也就是说如果我们自定义了这个类型的 bean，则负载均衡的策略就会被改变。</p><p>这个配置类千万不要加@Configuration 注解，也不要被 SpringBootApplication 扫描到。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_88dcedb4.png" alt="pic_88dcedb4.png"></p><blockquote><p>由于这个 OpenFeignConfig 没有加@Configuration 注解，也就没有被 Spring 加载，因此是不会生效的。接下来，我们要在启动类上通过注解来声明这个配置。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_0c5b3c7c.png" alt="pic_0c5b3c7c.png"></p><blockquote><p><code>RoundRobinLoadBalancer</code>是轮询算法，<code>RandomLoadBalancer</code>是随机算法，那么<code>NacosLoadBalancer</code>是什么负载均衡算法呢？</p></blockquote><blockquote><p>简单来说<code>NacosLoadBalancer</code>是一个基于权重的加权平均算法，我们打开 nacos 控制台，进入<code>item-service</code>的服务详情页，可以看到每个实例后面都有一个编辑按钮，在这里就可以修改每个服务的权重了：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_b1638609.png" alt="pic_b1638609.png"></p><h3 id="3-4、-服务容错机制"><a href="#3-4、-服务容错机制" class="headerlink" title="3.4、 服务容错机制"></a>3.4、 服务容错机制</h3><blockquote><p>由于微服务通信依赖于网络，可能会出现超时、失败等问题。服务容错机制可以保证系统的稳定性。</p></blockquote><h4 id="3-4-1、服务保护方案"><a href="#3-4-1、服务保护方案" class="headerlink" title="3.4.1、服务保护方案"></a>3.4.1、服务保护方案</h4><blockquote><p>微服务保护的方案有很多，比如：</p><ul><li>请求限流</li><li>线程隔离</li><li>服务熔断</li></ul></blockquote><blockquote><p>这些方案或多或少都会导致服务的体验上略有下降，比如请求限流，降低了并发上限；线程隔离，降低了可用资源数量；服务熔断，降低了服务的完整度，部分服务变的不可用或弱可用。因此这些方案都属于服务降级的方案。但通过这些方案，服务的健壮性得到了提升，接下来，我们就逐一了解这些方案的原理。</p></blockquote><p>请求限流</p><blockquote><p>服务故障最重要原因，就是并发太高！解决了这个问题，就能避免大部分故障。当然，接口的并发不是一直很高，而是突发的。因此请求限流，就是限制或控制接口访问的并发流量，避免服务因流量激增而出现故障。</p><p>请求限流往往会有一个限流器，数量高低起伏的并发请求曲线，经过限流器就变的非常平稳。这就像是水电站的大坝，起到蓄水的作用，可以通过开关控制水流出的大小，让下游水流始终维持在一个平稳的量。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_5dcdac23.png" alt="pic_5dcdac23.png"></p><p>线程隔离</p><blockquote><p>当一个业务接口响应时间长，而且并发高时，就可能耗尽服务器的线程资源，导致服务内的其它接口受到影响。所以我们必须把这种影响降低，或者缩减影响的范围。线程隔离正是解决这个问题的好办法。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_7a459a49.png" alt="pic_7a459a49.png"></p><p>服务熔断</p><blockquote><p>线程隔离虽然避免了雪崩问题，但故障服务依然会拖慢服务调用方的接口响应速度，这个时候就需要进行熔断以拒绝调用该接口。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_3f36eb3c.png" alt="pic_3f36eb3c.png"></p><h4 id="3-4-2、Sentinel"><a href="#3-4-2、Sentinel" class="headerlink" title="3.4.2、Sentinel"></a>3.4.2、Sentinel</h4><blockquote><p>Sentinel 是阿里巴巴开源的一款 分布式系统流量防护组件，主要用于实现流量控制（Flow Control）、熔断降级（Circuit Breaking）和系统自适应保护（System Adaptive Protection）等功能，是保障微服务系统稳定性的重要工具。</p></blockquote><p>下载地址：</p><p><a href="https://github.com/alibaba/Sentinel/releases">Releases · alibaba&#x2F;Sentinel (github.com)https://github.com/alibaba/Sentinel/releases<img src="https://api.smain.cn/pics/pic_da463f82.png" alt="pic_da463f82.png">https://github.com/alibaba/Sentinel/releases</a>然后运行如下命令启动控制台：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -Dserver.port=<span class="number">8090</span> -Dcsp.sentinel.dashboard.server=localhost:<span class="number">8090</span> -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar</span><br></pre></td></tr></table></figure><p>建议是写成.bat 文件然后双击启动：</p><p><img src="https://api.smain.cn/pics/pic_74b39e89.png" alt="pic_74b39e89.png"></p><p>访问<a href="http://localhost:8080/">http://localhost:8090</a>页面，就可以看到 sentinel 的控制台了：</p><p>需要输入账号和密码，默认都是：sentinel</p><p><img src="https://api.smain.cn/pics/pic_4fbc2f32.png" alt="pic_4fbc2f32.png"></p><blockquote><p>然后就是整合到你的项目中去，引入依赖并修改配置文件</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--sentinel--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8090</span></span><br><span class="line">      <span class="attr">http-method-specify:</span> <span class="literal">true</span> <span class="comment"># 开启请求方式前缀</span></span><br></pre></td></tr></table></figure><p><img src="https://api.smain.cn/pics/pic_1681c221.png" alt="pic_1681c221.png"></p><h4 id="3-4-3、请求限流"><a href="#3-4-3、请求限流" class="headerlink" title="3.4.3、请求限流"></a>3.4.3、请求限流</h4><p>直接在 sentinel 设置就行：</p><p><img src="https://api.smain.cn/pics/pic_6b3f9dfd.png" alt="pic_6b3f9dfd.png"></p><p><img src="https://api.smain.cn/pics/pic_ec3ef67d.png" alt="pic_ec3ef67d.png"></p><h4 id="3-4-4、线程隔离"><a href="#3-4-4、线程隔离" class="headerlink" title="3.4.4、线程隔离"></a>3.4.4、线程隔离</h4><p><img src="https://api.smain.cn/pics/pic_e9f1eede.png" alt="pic_e9f1eede.png"></p><blockquote><p>总的处理能力等于并发线程数乘上单机 QPS</p></blockquote><p><img src="https://api.smain.cn/pics/pic_daf71bfb.png" alt="pic_daf71bfb.png"></p><h4 id="3-4-5、服务熔断"><a href="#3-4-5、服务熔断" class="headerlink" title="3.4.5、服务熔断"></a>3.4.5、服务熔断</h4><p><img src="https://api.smain.cn/pics/pic_31fb73f1.png" alt="pic_31fb73f1.png"></p><p><img src="https://api.smain.cn/pics/pic_f33fbd76.png" alt="pic_f33fbd76.png"></p><h3 id="3-5、分布式事务"><a href="#3-5、分布式事务" class="headerlink" title="3.5、分布式事务"></a>3.5、分布式事务</h3><h4 id="3-5-1、Seata"><a href="#3-5-1、Seata" class="headerlink" title="3.5.1、Seata"></a>3.5.1、Seata</h4><blockquote><p>解决分布式事务的方案有很多，但实现起来都比较复杂，因此我们一般会使用开源的框架来解决分布式事务问题。在众多的开源分布式事务框架中，功能最完善、使用最多的就是阿里巴巴在 2019 年开源的 Seata 了。</p></blockquote><p><a href="https://seata.apache.org/zh-cn/docs/overview/what-is-seata/">Seata 是什么？ | Apache Seatahttps://seata.apache.org/zh-cn/docs/overview/what-is-seata/<img src="https://api.smain.cn/pics/pic_f30f1de4.png" alt="pic_f30f1de4.png">https://seata.apache.org/zh-cn/docs/overview/what-is-seata/</a></p><blockquote><p>其实分布式事务产生的一个重要原因，就是参与事务的多个分支事务互相无感知，不知道彼此的执行状态。因此解决分布式事务的思想非常简单：</p><p>就是找一个统一的事务协调者，与多个分支事务通信，检测每个分支事务的执行状态，保证全局事务下的每一个分支事务同时成功或失败即可。大多数的分布式事务框架都是基于这个理论来实现的。</p></blockquote><blockquote><p>Seata 也不例外，在 Seata 的事务管理中有三个重要的角色：</p><ol><li>TC (Transaction Coordinator) - 事务协调者：维护全局和分支事务的状态，协调全局事务提交或回滚。</li><li>TM (Transaction Manager) - 事务管理器：定义全局事务的范围、开始全局事务、提交或回滚全局事务。</li><li>RM (Resource Manager) - 资源管理器：管理分支事务，与 TC 交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li></ol></blockquote><p>Seata 的工作架构如图所示：</p><p><img src="https://api.smain.cn/pics/pic_e60aa4cf.png" alt="pic_e60aa4cf.png"></p><blockquote><p>其中，TM 和 RM 可以理解为 Seata 的客户端部分，引入到参与事务的微服务依赖中即可。将来 TM 和 RM 就会协助微服务，实现本地分支事务与 TC 之间交互，实现事务的提交或回滚。而 TC 服务则是事务协调中心，是一个独立的微服务，需要单独部署。</p></blockquote><blockquote><p>将 seata 部署然后访问（需要注意，要确保 nacos、mysql 都在同一个网络中）：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_d07a654e.png" alt="pic_d07a654e.png"></p><p>微服务集成 Seata</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--seata--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">registry:</span> <span class="comment"># TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span> <span class="comment"># 注册中心类型 nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.36</span><span class="number">.8</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">&quot;&quot;</span> <span class="comment"># namespace，默认为空</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span> <span class="comment"># 分组，默认是DEFAULT_GROUP</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-server</span> <span class="comment"># seata服务名称</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">hmall</span> <span class="comment"># 事务组名称</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span> <span class="comment"># 事务组与tc集群的映射关系</span></span><br><span class="line">      <span class="attr">hmall:</span> <span class="string">&quot;default&quot;</span></span><br><span class="line">  <span class="attr">data-source-proxy-mode:</span> <span class="string">XA</span></span><br></pre></td></tr></table></figure><h4 id="3-5-2、XA-模式"><a href="#3-5-2、XA-模式" class="headerlink" title="3.5.2、XA 模式"></a>3.5.2、XA 模式</h4><p><img src="https://api.smain.cn/pics/pic_e6d9217e.png" alt="pic_e6d9217e.png"></p><blockquote><p>RM 一阶段的工作：</p><ul><li>注册分支事务到 TC</li><li>执行分支业务 sql 但不提交</li><li>报告执行状态到 TC</li></ul><p>TC 二阶段的工作：</p><p>TC 检测各分支事务执行状态</p><ul><li>如果都成功，通知所有 RM 提交事务</li><li>如果有失败，通知所有 RM 回滚事务</li></ul><p>RM 二阶段的工作：</p><ul><li>接收 TC 指令，提交或回滚事务</li></ul></blockquote><p>进行测试，可以发现事务成功回滚：</p><p><img src="https://api.smain.cn/pics/pic_94cbcb7b.png" alt="pic_94cbcb7b.png"></p><blockquote><p>XA 模式的优点是什么？</p><ul><li>事务的强一致性，满足 ACID 原则</li><li>常用数据库都支持，实现简单，并且没有代码侵入</li></ul><p>XA 模式的缺点是什么？</p><ul><li>因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差</li><li>依赖关系型数据库实现事务</li></ul></blockquote><h4 id="3-5-3、AT-模式"><a href="#3-5-3、AT-模式" class="headerlink" title="3.5.3、AT 模式"></a>3.5.3、AT 模式</h4><blockquote><p>AT 模式同样是分阶段提交的事务模型，不过缺弥补了 XA 模型中资源锁定周期过长的缺陷。</p></blockquote><p>Seata 的 AT 模型：</p><p><img src="https://api.smain.cn/pics/pic_b8633d02.png" alt="pic_b8633d02.png"></p><blockquote><p>阶段一 RM 的工作：</p><ul><li>注册分支事务</li><li>记录 undo-log（数据快照）</li><li>执行业务 sql 并提交</li><li>报告事务状态</li></ul><p>阶段二提交时 RM 的工作：</p><ul><li>删除 undo-log 即可</li></ul><p>阶段二回滚时 RM 的工作：</p><ul><li>根据 undo-log 恢复数据到更新前</li></ul></blockquote><p>AT 模式与 XA 模式的最大区别：</p><table>  <tbody>   <tr>    <td>维度</td>    <td>AT 模式</td>    <td>XA 模式</td>   </tr>   <tr>    <td>锁定范围</td>    <td>业务逻辑层的状态，锁定时间短</td>    <td>数据库资源（行或表），锁定时间长</td>   </tr>   <tr>    <td>一致性</td>    <td>最终一致性，通过补偿机制实现</td>    <td>强一致性，依赖数据库的两阶段提交</td>   </tr>  </tbody> </table><h2 id="4、案例演示：微服务调用的完整流程"><a href="#4、案例演示：微服务调用的完整流程" class="headerlink" title="4、案例演示：微服务调用的完整流程"></a>4、案例演示：微服务调用的完整流程</h2><blockquote><p>这一部分我将通过消息队列对服务之间的异步调用进行演示，同时讲一下延迟消息的实现。</p></blockquote><p>先让我们来看一下什么是延迟消息：</p><p><img src="https://api.smain.cn/pics/pic_14547a3b.png" alt="pic_14547a3b.png"></p><p><img src="https://api.smain.cn/pics/pic_b350093e.png" alt="pic_b350093e.png"></p><blockquote><p>其中 ttl.queue 队列由于没用消费者监听，那么它的消息就会成为死信，我们将其绑定到对应的死信交换机上，这个时候如果由消费者来监听就能够成功接收消息，但是此时距离消息发送已经过去了一段时间，所以产生了延时。</p></blockquote><blockquote><p>但是！基于死信队列虽然可以实现延迟消息，但太麻烦了。因此 RabbitMQ 社区提供了一个延迟消息插件来实现相同的效果。</p></blockquote><p><a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">rabbitmq&#x2F;rabbitmq-delayed-message-exchange: Delayed Messaging for RabbitMQ (github.com)https://github.com/rabbitmq/rabbitmq-delayed-message-exchange<img src="https://api.smain.cn/pics/pic_cd3d336a.png" alt="pic_cd3d336a.png">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange</a>这样我们就能够使用注解的方式直接发送延时消息了：</p><p><img src="https://api.smain.cn/pics/pic_def6e004.png" alt="pic_def6e004.png"></p><blockquote><p>介绍完了延时消息，下面进行案例演示，以下是项目流程图：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_02afc096.png" alt="pic_02afc096.png"></p><blockquote><p>这里描述主要流程，涉及三个服务：订单服务、支付服务 和 商品服务。当用户提交订单后，系统将依次完成以下步骤：</p></blockquote><blockquote><ul><li>扣减库存：调用商品服务扣减对应商品的库存。</li><li>创建支付订单：订单服务创建支付订单，并跳转至支付服务。</li><li>支付处理：用户在支付服务中完成支付，支付成功后，支付服务通过消息通知订单服务支付成功。</li><li>消息丢失处理：如果支付服务长时间未向订单服务返回支付成功的消息（可能由于消息丢失），订单服务会通过延迟消息机制检测到异常。</li><li>关闭订单：订单服务将支付订单状态修改为 已关闭，并调用支付服务将支付状态同步为 已取消。</li><li>恢复库存：订单服务调用商品服务，恢复相应的商品库存。</li></ul></blockquote><blockquote><p>这样，通过延迟消息机制和状态回滚，系统能够有效应对消息丢失，确保最终一致性。</p></blockquote><p>改造下单业务，发送延迟消息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5.发送延迟消息，检测订单支付状态</span></span><br><span class="line">rabbitTemplate.convertAndSend(</span><br><span class="line">    MQConstants.DELAY_EXCHANGE_NAME,</span><br><span class="line">    MQConstants.DELAY_ORDER_KEY,</span><br><span class="line">    order.getId(),</span><br><span class="line">    message -&gt; &#123;</span><br><span class="line">        message.getMessageProperties().setDelay(<span class="number">1800000</span>); <span class="comment">// 延时30分钟</span></span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这里将 交换机 和 Routing key 写成了一个常量类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MQConstants</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">DELAY_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;trade.delay.direct&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">DELAY_ORDER_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;trade.delay.order.queue&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">DELAY_ORDER_KEY</span> <span class="operator">=</span> <span class="string">&quot;delay.order.query&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写监听消息，查询支付状态：</p><p><img src="https://api.smain.cn/pics/pic_88be4dac.png" alt="pic_88be4dac.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDelayMessageListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IOrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PayClient payClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = MQConstants.DELAY_ORDER_QUEUE_NAME),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = MQConstants.DELAY_EXCHANGE_NAME, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            key = MQConstants.DELAY_ORDER_KEY</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenOrderDelayMessage</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询订单</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderService.getById(orderId);</span><br><span class="line">        <span class="comment">// 2.检测订单状态，判断是否支付</span></span><br><span class="line">        <span class="keyword">if</span>(order == <span class="literal">null</span> || order.getStatus() != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 不存在或者是已支付</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.未支付，需要查询支付流水状态</span></span><br><span class="line">        <span class="type">PayOrderDTO</span> <span class="variable">payOrder</span> <span class="operator">=</span> payClient.queryPayOrderByBizOrderNo(orderId);</span><br><span class="line">        <span class="comment">// 4.判断是否支付</span></span><br><span class="line">        <span class="keyword">if</span>(payOrder != <span class="literal">null</span> &amp;&amp; payOrder.getStatus() == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="comment">// 4.1.已支付，标记订单状态为已支付</span></span><br><span class="line">            orderService.markOrderPaySuccess(orderId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 4.2.未支付，取消订单，恢复库存</span></span><br><span class="line">            orderService.cancelOrder(orderId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从这个类绑定的交换机不难看出它就是用来处理延时消息后的逻辑的，其中查询支付状态已经实现，我们拿到支付状态后如果已支付就可以直接对订单的状态进行更改，但是如果消息超时了就需要进行回滚操作也就是其中的 cancelOrder 方法，下面就来实现这个方法。</p></blockquote><p>cancelOrder</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancelOrder</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.修改交易订单状态为已关闭</span></span><br><span class="line">    lambdaUpdate()</span><br><span class="line">            .set(Order::getStatus, <span class="number">5</span>)</span><br><span class="line">            .eq(Order::getId, orderId)</span><br><span class="line">            .update();</span><br><span class="line">    <span class="comment">// 2.修改支付状态为已取消</span></span><br><span class="line">    payClient.updatePayOrderStatusByBizOrderNo(orderId, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 3.恢复库存</span></span><br><span class="line">    List&lt;OrderDetail&gt; list = detailService.lambdaQuery().eq(OrderDetail::getOrderId, orderId).list();</span><br><span class="line">    List&lt;OrderDetailDTO&gt; orderDetailDTOS = BeanUtils.copyToList(list, OrderDetailDTO.class);</span><br><span class="line">    itemClient.restoreStock(orderDetailDTOS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中的更新支付状态以及回复库存的接口还需要我们实现</p></blockquote><p>payClient</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;pay-service&quot;, fallbackFactory = PayClientFallback.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PayClient</span> &#123;</span><br><span class="line">    <span class="meta">@PutMapping(&quot;/pay-orders/status/&#123;id&#125;/&#123;status&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updatePayOrderStatusByBizOrderNo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long orderId, <span class="meta">@PathVariable(&quot;status&quot;)</span> Integer status)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>payController</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;修改支付订单状态&quot;)</span></span><br><span class="line"><span class="meta">@PutMapping(&quot;/status/&#123;id&#125;/&#123;status&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updatePayOrderStatusByBizOrderNo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long orderId, <span class="meta">@PathVariable(&quot;status&quot;)</span> Integer status)</span>&#123;</span><br><span class="line">    payOrderService.updateStatusByOrderId(orderId, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>payServiceImpl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateStatusByOrderId</span><span class="params">(Long orderId, Integer status)</span> &#123;</span><br><span class="line">    lambdaUpdate()</span><br><span class="line">            .set(PayOrder::getStatus, status)</span><br><span class="line">            .eq(PayOrder::getBizOrderNo, orderId) <span class="comment">//注意这里第一个参数是拿支付表中的订单id而不是支付id</span></span><br><span class="line">            .update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>itemClient</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;item-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line">    <span class="meta">@PutMapping(&quot;/items/stock/restore&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">restoreStock</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;OrderDetailDTO&gt; orderDetails)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>itemController</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;恢复库存&quot;)</span></span><br><span class="line"><span class="meta">@PutMapping(&quot;/stock/restore&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreStock</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;OrderDetailDTO&gt; orderDetails)</span> &#123;</span><br><span class="line">    itemService.restoreStock(orderDetails);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>itemServiceImpl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreStock</span><span class="params">(List&lt;OrderDetailDTO&gt; orderDetails)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(OrderDetailDTO orderDetail : orderDetails) &#123;</span><br><span class="line">        <span class="comment">// 根据商品id查询商品</span></span><br><span class="line">        <span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> lambdaQuery().eq(Item::getId, orderDetail.getItemId()).one();</span><br><span class="line">        <span class="comment">// 还原库存</span></span><br><span class="line">        lambdaUpdate()</span><br><span class="line">                .set(Item :: getStock, item.getStock() + orderDetail.getNum())</span><br><span class="line">                .eq(Item::getId, orderDetail.getItemId())</span><br><span class="line">                .update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>至此所有功能开发完毕，进行测试看商品数据是否恢复，支付状态是否更新：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_1f74dbeb.png" alt="pic_1f74dbeb.png"></p><p><img src="https://api.smain.cn/pics/pic_8725c95f.png" alt="pic_8725c95f.png"></p><h2 id="5、结语"><a href="#5、结语" class="headerlink" title="5、结语"></a>5、结语</h2><blockquote><p>微服务架构为现代应用提供了更高的灵活性和可扩展性，同时也带来了更多的挑战。在本文中，我们通过实际案例，探讨了服务调用的全过程，分析了同步和异步调用的不同场景，并介绍了如何利用负载均衡、服务注册与发现等关键技术来实现微服务间的高效通信。</p><p>尽管微服务架构能极大提升开发和部署的效率，但在实际应用中，我们仍需面对分布式事务、服务治理等问题。未来的学习中，深入理解这些问题并探索解决方案，将帮助我们构建更可靠、更高效的分布式系统。</p><p>希望这篇文章能为你在微服务的学习和实践上提供一些思路，也期待我们在这个领域不断积累经验，迎接更多的挑战。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springcloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux（Centos7）安装docker、mysql踩坑总结</title>
      <link href="/2025/01/12/Linux%EF%BC%88Centos7%EF%BC%89%E5%AE%89%E8%A3%85docker%E3%80%81mysql%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93/"/>
      <url>/2025/01/12/Linux%EF%BC%88Centos7%EF%BC%89%E5%AE%89%E8%A3%85docker%E3%80%81mysql%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要是记录了在 CentOS 7 上安装 Docker 和 MySQL 时遇到的一些问题，主要是由于镜像源未配置正确，导致无法顺利下载所需的依赖包。下面将介绍在安装过程中遇到的困难，并分享如何通过配置合适的镜像源来解决这些问题，从而顺利完成 Docker 和 MySQL 的安装，希望能够帮到有需要的人。</p></blockquote><h4 id="一、安装准备"><a href="#一、安装准备" class="headerlink" title="一、安装准备"></a>一、安装准备</h4><blockquote><p>系统版本：CentOS 7</p><p>先安装 yum：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><blockquote><p>执行之前先配置一下镜像源，输入以下命令进入配置文件：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vim /etc/yum.repos.d/CentOS-Base.repo</span><br></pre></td></tr></table></figure><blockquote><p>再将 mirrorlist 注释掉然后将 baseurl 改为阿里云镜像，然后保存退出</p></blockquote><p><img src="https://api.smain.cn/pics/pic_8fcb7204.png" alt="pic_8fcb7204.png"></p><blockquote><p>一定要将 mirrorlist 注释掉！不然还是会直接访问官方源导致下载失败！</p></blockquote><blockquote><p>输入下面的命令检验是否安装成功：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_22eea1b9.png" alt="pic_22eea1b9.png"></p><blockquote><p>当然不排除网络问题，可以先用 ping 命令测试一下网络是否连通：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_869db52c.png" alt="pic_869db52c.png"></p><blockquote><p>只要网络连通，并且配置文件修改无误就肯定能安装成功。</p></blockquote><h4 id="二、安装-Docker"><a href="#二、安装-Docker" class="headerlink" title="二、安装 Docker"></a>二、安装 Docker</h4><blockquote><p>执行下列命令安装：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure><blockquote><p>下面是 Docker 的一些常用命令：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 启动Docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 停止Docker</span><br><span class="line">systemctl stop docker</span><br><span class="line"></span><br><span class="line"># 重启</span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line"># 设置开机自启</span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line"># 执行docker ps命令，如果不报错，说明安装启动成功</span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"># 列出本地 Docker 主机上已经下载或构建的所有镜像</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><blockquote><p>可以看到刚刚安装好 docker 后是没有镜像的：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_e644b8d0.png" alt="pic_e644b8d0.png"></p><h4 id="三、安装-MySQL"><a href="#三、安装-MySQL" class="headerlink" title="三、安装 MySQL"></a>三、安装 MySQL</h4><blockquote><p>现在要使用 docker 安装 mysql 镜像，注意如果之前有在虚拟机上安装过 mysql 要先停掉，不然会端口冲突：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">systemctl stop mysqld</span><br></pre></td></tr></table></figure><blockquote><p>如果直接 docker pull mysql，多半会报错：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Error response from daemon: Get <span class="string">&quot;https://registry-1.docker.io/v2/&quot;</span>: net/http: request canceled <span class="keyword">while</span> waiting <span class="keyword">for</span> <span class="title function_">connection</span> <span class="params">(Client.Timeout exceeded <span class="keyword">while</span> awaiting headers)</span></span><br></pre></td></tr></table></figure><blockquote><p>所以还是先配置镜像，值得一提的是在写这篇文章的时候阿里云的镜像加速已经停用了，所以得找别的镜像。</p></blockquote><blockquote><p>创建一个 docker 的配置文件，然后设置镜像源：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 创建目录</span><br><span class="line">mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line">#创建文件</span><br><span class="line">touch daemon.json</span><br><span class="line"></span><br><span class="line">#进入编辑</span><br><span class="line">vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://gallery.ecr.aws/&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://gitverse.ru/docs/artifactory/gitverse-registry/&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://docker.lmirror.top&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://atomhub.openatom.cn/&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这几个镜像目前测试是有效的，然后再 docker pull mysql</p><p>可以看到很快就下好了，再使用 docker images：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_dd193e67.png" alt="pic_dd193e67.png"></p><blockquote><p>成功拉取！最后下载 mysql：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p <span class="number">3306</span>:<span class="number">3306</span> \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=<span class="number">123</span> \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><blockquote><p>其中设置的用户名是 root ，密码是 123，如有需要自行更改。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_8fda741d.png" alt="pic_8fda741d.png"></p><blockquote><p>安装成功！来测试一下能否连接成功：</p><p>在 navicat 中新建连接，其中 Host 填你自己的虚拟机 IP 地址</p><p>使用 ifconfig 即可查看</p></blockquote><p><img src="https://api.smain.cn/pics/pic_c0b322a5.png" alt="pic_c0b322a5.png"></p><p><img src="https://api.smain.cn/pics/pic_bbd51289.png" alt="pic_bbd51289.png"></p><h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><blockquote><p>最后有几点需要注意：</p><p>1、重新启动虚拟机后需要再次停用原来的 mysql 防止端口冲突</p><p>2、开启 dokcer 后 mysql 并没有一并被开启，需要输入 dokcer start mysql 开启</p><p>3、如果发现数据库连接不上了可以考虑关闭虚拟机的防火墙</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 查看防火墙状态</span><br><span class="line">firewall-cmd --state</span><br><span class="line"></span><br><span class="line"># 关闭防火墙</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Python与Fiddler实现图书馆座位自动预约：实战经验分享</title>
      <link href="/2025/01/04/%E7%94%A8Python%E4%B8%8EFiddler%E5%AE%9E%E7%8E%B0%E5%9B%BE%E4%B9%A6%E9%A6%86%E5%BA%A7%E4%BD%8D%E8%87%AA%E5%8A%A8%E9%A2%84%E7%BA%A6%EF%BC%9A%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
      <url>/2025/01/04/%E7%94%A8Python%E4%B8%8EFiddler%E5%AE%9E%E7%8E%B0%E5%9B%BE%E4%B9%A6%E9%A6%86%E5%BA%A7%E4%BD%8D%E8%87%AA%E5%8A%A8%E9%A2%84%E7%BA%A6%EF%BC%9A%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：</p><p>期末周图书馆座位总是供不应求，每天早上七点开始预约，不到十分钟位置就被抢光。对于我们这些爱睡懒觉的人来说，简直是噩梦！而恰好这学期我正在学习计算机网络课程，何不趁机动手写一个自动预约程序，解决这个问题呢？于是这篇博客应运而生。</p><p>免责声明：</p><p>本博客仅供计算机网络爱好者学习交流使用，请勿用于非法用途！</p></blockquote><p>目录</p><p><a href="#%E4%B8%80%E3%80%81%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90">一、需求分析</a></p><p><a href="#%E4%BA%8C%E3%80%81%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%87%86%E5%A4%87">二、开发工具准备</a></p><p><a href="#%E4%B8%89%E3%80%81%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0">三、功能实现</a></p><h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><blockquote><p>我们的目标很明确，那就是使用自动化脚本实现图书馆座位的预约。我所在的学校由于只能通过微信公众号来进行预约，所以相较于能够直接在网站上预约的学校来说，数据抓包相对复杂一点，所以才会用到 fidder，不然直接浏览器 F12 就可以直接看数据包了。</p></blockquote><p>让我们来分析一下要干些什么事情：</p><blockquote><ol><li>使用电脑登陆微信，进入公众号模拟预约</li><li>使用 fidder 对刚才的操作进行抓包</li><li>对数据包经行分析，提取出对应的用户登录数据以及座位预约信息</li><li>使用 Python 的 requests 库模拟用户向图书馆服务器发送预约请求</li><li>编辑定时器固定在早上 7 点执行程序</li></ol></blockquote><h3 id="二、开发工具准备"><a href="#二、开发工具准备" class="headerlink" title="二、开发工具准备"></a>二、开发工具准备</h3><blockquote><p>明确了需求，下面来准备开发工具。</p></blockquote><h4 id="1、首先先安装好-Python"><a href="#1、首先先安装好-Python" class="headerlink" title="1、首先先安装好 Python"></a>1、首先先安装好 Python</h4><p><a href="http://www.python.org/download/">http://www.python.org/download/</a></p><p>安装步骤其他博客已经讲的非常详细了，这里就不多说了</p><h4 id="2、然后介绍一下-Python-requests-库："><a href="#2、然后介绍一下-Python-requests-库：" class="headerlink" title="2、然后介绍一下 Python requests 库："></a>2、然后介绍一下 Python requests 库：</h4><blockquote><p>requests 是一个非常流行且易于使用的 Python 库，用于发送 HTTP 请求并与 Web 服务器进行交互。它简化了 HTTP 请求的工作流程，提供了简单的接口来进行常见的 HTTP 操作，例如 GET、POST、PUT、DELETE 等。</p><p>这次主要是用到了 post 函数向服务器发送预约请求，将 url、headers、data 这三个数据解析好之后就通过 requests.post 发送。</p></blockquote><p>我这里用的是 VScode 进行开发，只需要在终端输入如下命令，即可完成 requests 库的安装：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install requests</span><br></pre></td></tr></table></figure><p>然后在命令行可通过导入 import 库来测试 requests 是否安装成功：</p><p><img src="https://api.smain.cn/pics/pic_1f98df1b.png" alt="pic_1f98df1b.png"></p><p>这样就算是装好了</p><h4 id="3、下面介绍这次的关键抓包工具-fidder"><a href="#3、下面介绍这次的关键抓包工具-fidder" class="headerlink" title="3、下面介绍这次的关键抓包工具 fidder"></a>3、下面介绍这次的关键抓包工具 fidder</h4><blockquote><p>Fiddler 是最常用的 Web 调试工具之一。对于开发来说，前端可以通过 Fiddler 代理来调试 JS、CSS、HTML 样式。后端可以通过 Fiddler 查看请求和相应，定位问题。对于测试来说，可以通过抓包方式修改前端请求参数和模拟后端返回，快速定位缺陷。总之，不管是开发还是测试，Fiddler 都是一款工作中不可或缺的辅助利器。</p></blockquote><p>官网：<a href="https://www.telerik.com/fiddler">https://www.telerik.com/fiddler</a></p><p>安装过程就是无脑下一步就行了，装好后点击 <code>Fiddler.exe</code> 运行：</p><p><img src="https://api.smain.cn/pics/pic_704efb9d.png" alt="pic_704efb9d.png"></p><blockquote><p>看上去有点复杂，不过不要慌，我们只需要会用基本的功能就可以了</p></blockquote><p>下面来配置 fidder：</p><blockquote><p>启用 HTTPS 解密</p><ol><li><p>在 Fiddler 菜单中，点击 <code>Tools &gt; Options</code>。</p></li><li><p>选择 <code>HTTPS</code> 标签页，勾选：</p><ul><li><code>Capture HTTPS CONNECTs</code></li><li><code>Decrypt HTTPS traffic</code></li></ul></li><li><p>点击 <code>Actions &gt; Trust Root Certificate</code>，安装 Fiddler 的证书。</p></li></ol></blockquote><p><img src="https://api.smain.cn/pics/pic_464cb2c6.png" alt="pic_464cb2c6.png"></p><p><img src="https://api.smain.cn/pics/pic_25ea9037.png" alt="pic_25ea9037.png"></p><blockquote><p>设置抓包范围</p><ol><li>选择 <code>Tools &gt; Options &gt; Connections</code>。</li><li>确保 <code>Allow remote computers to connect</code> 已勾选。</li><li>记下 Fiddler 的监听端口（默认是 8888）。</li></ol></blockquote><p><img src="https://api.smain.cn/pics/pic_dfdc7fd3.png" alt="pic_dfdc7fd3.png"></p><blockquote><p>配置系统代理</p><p>抓取电脑端微信的流量，需要将微信的数据流经 Fiddler。</p><p>在 Windows 系统设置代理</p><ol><li><p>打开设置 -&gt; 网络和 Internet -&gt; 代理</p></li><li><p>启用 使用代理服务器，并填写代理地址</p></li></ol><p>地址： 127.0.0.1</p><p>端口： 8888（与 fidder 配置一致）</p></blockquote><p><img src="https://api.smain.cn/pics/pic_26713077.png" alt="pic_26713077.png"></p><blockquote><p>到这里，fidder 就已经能够对微信的数据流进行监听了！</p></blockquote><h3 id="三、功能实现"><a href="#三、功能实现" class="headerlink" title="三、功能实现"></a>三、功能实现</h3><blockquote><p>现在工具都准备好了，我们马上开干！</p></blockquote><h4 id="1、执行预约流程并分析抓包数据"><a href="#1、执行预约流程并分析抓包数据" class="headerlink" title="1、执行预约流程并分析抓包数据"></a>1、执行预约流程并分析抓包数据</h4><blockquote><p>（1）打开微信客户端：</p><p>检查 fidder 中数据流是否检查到微信。</p><p>（2）进入预约界面：</p><p>打开图书馆预约系统，执行预约操作（选择座位、时间）然后提交表单。</p><p>（3）监控 fidder：</p><p>点击左侧的对应网络请求</p></blockquote><p><img src="https://api.smain.cn/pics/pic_c60379ff.png" alt="pic_c60379ff.png"></p><blockquote><p>然后点击 Inspectors 查看数据包，再点击 Row 将整个请求显示为纯文本：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_b1b01776.png" alt="pic_b1b01776.png"></p><blockquote><p>然后查看具体响应内容：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_cccc60d1.png" alt="pic_cccc60d1.png"></p><blockquote><p>以下内容需要重点关注：</p><ul><li>目标 URL</li><li>Cookies</li></ul></blockquote><blockquote><p>其中 URL 指明了目标访问地址 ，Cookies 中包含了你的用户身份信息，以及你的选座信息。</p></blockquote><h4 id="2、模拟请求"><a href="#2、模拟请求" class="headerlink" title="2、模拟请求"></a>2、模拟请求</h4><blockquote><p>新建一个.py 文件，引入 requests 然后将数据复制过来</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># URL 地址</span></span><br><span class="line">url = <span class="string">&quot; &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求头，从 Raw 中提取</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;Connection&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;X-Requested-With&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;Origin&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;Sec-Fetch-Site&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;Sec-Fetch-Mode&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;Sec-Fetch-Dest&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;Referer&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;Cookie&quot;</span>: <span class="string">&quot; &quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 表单数据模板</span></span><br><span class="line">data_template = &#123;</span><br><span class="line">    <span class="string">&quot;code&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;data_type&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;seatdate&quot;</span>: <span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;seatno&quot;</span>：<span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;seatname&quot;</span>:<span class="string">&quot; &quot;</span>,</span><br><span class="line">    <span class="string">&quot;datetime&quot;</span>: <span class="string">&quot; &quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>发送 POST 请求</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response = requests.post(url, headers=headers, data=data)</span><br></pre></td></tr></table></figure><blockquote><p>然后运行程序，如果看到输出状态码为 200，就表明成功与服务器交换数据，然后根据返回信息查看是否预约成功。这里推荐使用日志记录一下，这样调试起来也更方便。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置日志记录</span></span><br><span class="line">logging.basicConfig(</span><br><span class="line">    filename=<span class="string">&quot; &quot;</span>,  <span class="comment"># 设置日志文件路径</span></span><br><span class="line">    level=logging.INFO,  <span class="comment"># 日志等级</span></span><br><span class="line">    <span class="built_in">format</span>=<span class="string">&quot;%(asctime)s - %(levelname)s - %(message)s&quot;</span>,  <span class="comment"># 日志格式</span></span><br><span class="line">    filemode=<span class="string">&#x27;a&#x27;</span>,  <span class="comment"># 追加写入模式</span></span><br><span class="line">    encoding=<span class="string">&#x27;utf-8&#x27;</span>  <span class="comment"># 设置编码格式为utf-8</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录响应信息</span></span><br><span class="line">    logging.info(<span class="string">f&quot;状态码: <span class="subst">&#123;response.status_code&#125;</span>&quot;</span>)</span><br><span class="line">    logging.info(<span class="string">f&quot;响应内容: <span class="subst">&#123;response.text&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>如果响应数据没问题，那就成功了！下一步就是设置一个定时任务让这个程序在每天早上 7 点准时执行。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_57297dcf.png" alt="pic_57297dcf.png"></p><blockquote><p>打开任务计划程序，创建定时任务</p></blockquote><p><img src="https://api.smain.cn/pics/pic_685cedde.png" alt="pic_685cedde.png"></p><p><img src="https://api.smain.cn/pics/pic_8824802d.png" alt="pic_8824802d.png"></p><p><img src="https://api.smain.cn/pics/pic_e8353aa9.png" alt="pic_e8353aa9.png"></p><p><img src="https://api.smain.cn/pics/pic_cf127d9c.png" alt="pic_cf127d9c.png"></p><p><img src="https://api.smain.cn/pics/pic_054c03d2.png" alt="pic_054c03d2.png"></p><blockquote><p>创建好后直接执行测试一下，然后取日志里看是否正常，如果一切正常，那就大功告成了！</p></blockquote><p><img src="https://api.smain.cn/pics/pic_2ae276db.png" alt="pic_2ae276db.png"></p><blockquote><p>最后再次声明一下，如果没有预约成功，请你在调试的时候一定要检查清楚代码的逻辑后再运行！不要短时间内多次访问服务器！否则有可能被检测到然后封禁！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> fiddler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于若依框架的SpringBoot管理系统学习</title>
      <link href="/2024/10/24/%E5%9F%BA%E4%BA%8E%E8%8B%A5%E4%BE%9D%E6%A1%86%E6%9E%B6%E7%9A%84SpringBoot%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/10/24/%E5%9F%BA%E4%BA%8E%E8%8B%A5%E4%BE%9D%E6%A1%86%E6%9E%B6%E7%9A%84SpringBoot%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote><p>在现代企业开发中，快速搭建高效、稳定的管理系统是一个常见的需求。而若依框架作为一个基于 SpringBoot 的开源管理系统框架，凭借其模块化设计、便捷的代码生成工具以及优秀的前端整合方案，成为了许多开发者的首选。对于初学者来说，若依框架不仅是学习 SpringBoot 开发的良好切入点，也是深入理解后台管理系统开发流程的最佳实践平台。</p><p>本文将结合学习若依框架的实际过程，从框架搭建到核心功能实现，对其中的重要知识点和开发技巧进行深入解析，帮助读者快速上手并掌握若依框架的使用技巧，同时为开发自己的管理系统打下坚实的基础。</p></blockquote><h4 id="一、什么是若依？"><a href="#一、什么是若依？" class="headerlink" title="一、什么是若依？"></a>一、什么是若依？</h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h5><blockquote><p>若依框架（RuoYi）是一个基于 SpringBoot 和 Vue 的快速开发平台，常用于构建后台管理系统。它采用前后端分离的架构，前端使用 Vue.js，后端使用 SpringBoot，数据库则支持多种类型（如 MySQL、MariaDB 等）。框架集成了一些主流的开源组件，如 MyBatis、Redis、Druid、Swagger 等，使得开发人员能够快速搭建和扩展项目功能。</p></blockquote><blockquote><p>gitee 地址：</p><p>后端 <a href="https://gitee.com/y_project/RuoYi">https://gitee.com/y_project&#x2F;RuoYi</a></p><p>前端 <a href="https://gitee.com/y_project/RuoYi-Vue">https://gitee.com/y_project&#x2F;RuoYi-Vue</a></p></blockquote><blockquote><p>技术版本：</p><ul><li>JDK &gt;&#x3D; 1.8</li><li>MySQL &gt;&#x3D; 5.7</li><li>Maven &gt;&#x3D; 3.0</li><li>Node &gt;&#x3D; 12</li><li>Redis &gt;&#x3D; 3</li></ul></blockquote><h5 id="2-若依框架的特点"><a href="#2-若依框架的特点" class="headerlink" title="2.若依框架的特点"></a>2.若依框架的特点</h5><blockquote><ul><li>模块化设计：内置了用户管理、角色权限、菜单管理、操作日志、定时任务等常见的管理系统功能模块，可以快速搭建企业级应用。</li><li>前后端分离：前端与后端独立开发和部署，提高了开发效率和用户体验。</li><li>丰富的技术栈集成：集成了多种常用的技术和工具（如 MyBatis 做数据持久化，Redis 做缓存，Druid 作为数据库连接池），简化了开发过程。</li><li>高扩展性：代码结构清晰，支持二次开发，可以根据业务需求进行自定义扩展。</li></ul></blockquote><h5 id="3-若依框架的目录结构"><a href="#3-若依框架的目录结构" class="headerlink" title="3.若依框架的目录结构"></a>3.若依框架的目录结构</h5><blockquote><p>若依的后端项目主要分为六个模块，他们之间的依赖关系如下图所示：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_59f382bd.png" alt="pic_59f382bd.png"></p><p>下面我们来分析一下每个模块的具体功能</p><p><img src="https://api.smain.cn/pics/pic_e9c40141.png" alt="pic_e9c40141.png"></p><p><img src="https://api.smain.cn/pics/pic_1c2520b9.png" alt="pic_1c2520b9.png"></p><p><img src="https://api.smain.cn/pics/pic_1e9d8b33.png" alt="pic_1e9d8b33.png"></p><p><img src="https://api.smain.cn/pics/pic_aa8ccf3b.png" alt="pic_aa8ccf3b.png"></p><blockquote><p>从上面的几张图我们可以看出若依的主要框架包括 admin、common、framework 和 system，至于 quartz 和 generator 它们并不是必须的，但是有了它们，可以大大加快我们程序的开发速度，后面我们会讲到如何使用。</p></blockquote><p>若依的配置文件主要放在-admin 包中</p><p><img src="https://api.smain.cn/pics/pic_16f83402.png" alt="pic_16f83402.png"></p><p>接下来是项目相关的数据库表</p><p><img src="https://api.smain.cn/pics/pic_3d67c75b.png" alt="pic_3d67c75b.png"></p><p>然后让我们来看看前端的项目结构</p><blockquote><p>这张图完整了列出了前端项目的框架，但是如果你像我一样重心放在后端开发，那其实只需要了解其中一部份模块的功能就行了，下面这张图列出了后端人员经常需要用到的几个模块。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_39357e97.png" alt="pic_39357e97.png"></p><p>下面们来分析一下若依后端的具体代码</p><blockquote><p>首先从 Controller 开始，若依框架中的 Controller 都继承了 BaseController 类，实现了基本的数据分页展示功能、用户登录相关方法、以及请求成功或者失败后的相关处理。可以说，若依的这个 BaseController 类基本上实现了业务开发所要用到的大多数常用功能。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_8f67fd18.png" alt="pic_8f67fd18.png"></p><blockquote><p>然后是我们比较关心的返回对象的封装，若依将返回对象分为了两类，一类是分页查询返回对象，另一类是增删改查返回对象。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_9d46515e.png" alt="pic_9d46515e.png"></p><p><img src="https://api.smain.cn/pics/pic_b2b81c37.png" alt="pic_b2b81c37.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;@ss.hasPermi(&#x27;manage:partner:list&#x27;)&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> TableDataInfo <span class="title function_">list</span><span class="params">(Partner partner)</span></span><br><span class="line">    &#123;</span><br><span class="line">        startPage();</span><br><span class="line">        List&lt;PartnerVo&gt; list = partnerService.selectPartnerVOList(partner);</span><br><span class="line">        <span class="keyword">return</span> getDataTable(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/captchaImage&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> AjaxResult <span class="title function_">getCode</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">AjaxResult</span> <span class="variable">ajax</span> <span class="operator">=</span> AjaxResult.success();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">captchaEnabled</span> <span class="operator">=</span> configService.selectCaptchaEnabled();</span><br><span class="line">        ajax.put(<span class="string">&quot;captchaEnabled&quot;</span>, captchaEnabled);</span><br><span class="line">        <span class="keyword">if</span> (!captchaEnabled)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ajax;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><blockquote><p>值得一提的是@PreAuthorize 注解是 Spring Security 的一个权限认证注解，它与前端联调之后能够实现权限控制访问。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;@ss.hasPermi(&#x27;manage:partner:edit&#x27;)&quot;)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;el-button link type=<span class="string">&quot;primary&quot;</span> <span class="meta">@click</span>=<span class="string">&quot;resetPassword(scope.row)&quot;</span> v-hasPermi=<span class="string">&quot;[&#x27;manage:partner:edit&#x27;]&quot;</span>&gt;重置密码&lt;/el-button&gt;</span><br></pre></td></tr></table></figure><p><img src="https://api.smain.cn/pics/pic_c06ad374.png" alt="pic_c06ad374.png"></p><p>前后端交互流程：</p><p><img src="https://api.smain.cn/pics/pic_e4586998.png" alt="pic_e4586998.png"></p><p><img src="https://api.smain.cn/pics/pic_471e64aa.png" alt="pic_471e64aa.png"></p><h4 id="二、若依框架的项目搭建"><a href="#二、若依框架的项目搭建" class="headerlink" title="二、若依框架的项目搭建"></a>二、若依框架的项目搭建</h4><h5 id="1-后端项目初始化配置"><a href="#1-后端项目初始化配置" class="headerlink" title="1.后端项目初始化配置"></a>1.后端项目初始化配置</h5><h6 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h6><blockquote><p>将后端代码克隆的本地后会有两个 sql 脚本，先创建好你的数据库然后修改数据库连接配置</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    druid:</span><br><span class="line">      url: jdbc:mysql:<span class="comment">//localhost:3306/ruoyi?</span></span><br><span class="line">      useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf8&amp;serverTimezone=UTC</span><br><span class="line">      username: your_db_username</span><br><span class="line">      password: your_db_password</span><br></pre></td></tr></table></figure><blockquote><p>ruoyi 是数据库的名字，然后执行下面的 sql 脚本就行了。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_3c915a97.png" alt="pic_3c915a97.png"></p><h6 id="配置-Redis-缓存"><a href="#配置-Redis-缓存" class="headerlink" title="配置 Redis 缓存"></a>配置 Redis 缓存</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: <span class="number">6379</span></span><br><span class="line">    password: your_redis_password</span><br></pre></td></tr></table></figure><blockquote><p>注意：启动项目之前记得一定要把 Redis 打开，不然会报错。</p></blockquote><h6 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h6><blockquote><p>若依框架的依赖管理主要使用 Maven，<code>pom.xml</code>文件配置了各种依赖，包括 Spring Boot、MyBatis、Redis、Swagger 等。以下是主要依赖的说明：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.0</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h5 id="2-启动项目"><a href="#2-启动项目" class="headerlink" title="2.启动项目"></a>2.启动项目</h5><blockquote><p>启动后端项目：在<code>ruoyi-admin</code>目录下执行<code>RuoYiApplication</code>类中的<code>main</code>方法，启动 SpringBoot 后端服务。</p><p>启动前端项目：在<code>ruoyi-ui</code>目录下，执行以下命令安装依赖并启动前端服务：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h5 id="3-界面展示"><a href="#3-界面展示" class="headerlink" title="3.界面展示"></a>3.界面展示</h5><blockquote><p>成功启动后页面会自动跳转到如下登录界面，登录密码默认是 admin123，若依的密码使用了 MD5 加密存储，所以在数据库里面是看不到的。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_44fe88e3.png" alt="pic_44fe88e3.png"></p><h5 id="4-功能详讲"><a href="#4-功能详讲" class="headerlink" title="4.功能详讲"></a>4.功能详讲</h5><blockquote><p>若依框架的菜单功能是后台管理系统的核心部分，涵盖了系统管理、监控、工具等多种模块。以下是若依系统默认的菜单结构和功能介绍：</p><h6 id="1-系统管理"><a href="#1-系统管理" class="headerlink" title="1. 系统管理"></a>1. 系统管理</h6><p>主要用于管理系统中的基础设置和权限控制，包括用户、角色、菜单等内容。主要功能如下：</p><ul><li>用户管理<br>管理系统中的用户信息，包括新增、编辑、删除用户，以及为用户分配角色和重置密码等操作。</li><li>角色管理<br>定义系统中的角色，并为角色分配菜单权限。可以设置角色的权限范围，控制其可访问的菜单项。</li><li>菜单管理<br>用于配置系统的菜单显示和访问权限，支持添加、编辑、删除菜单项。可以设置菜单的类型（目录、菜单、按钮）、排序、图标等信息。</li><li>部门管理<br>维护系统的组织架构，支持树形结构显示部门信息。可以新增、编辑、删除部门，以及查看部门成员。</li><li>岗位管理<br>定义系统中的岗位信息，用于关联用户岗位。可以新增、编辑、删除岗位。</li><li>字典管理<br>管理系统中的字典数据，如状态、性别等常用数据项。可以为每个字典项设置标签和值。</li><li>参数设置<br>用于管理系统中的配置参数，可以动态修改参数值而无需重启服务。</li><li>通知公告<br>发布和管理系统内的公告信息，支持查看公告的详细内容。</li></ul><h6 id="2-系统监控"><a href="#2-系统监控" class="headerlink" title="2. 系统监控"></a>2. 系统监控</h6><p>主要用于监控系统的运行状态、日志记录等内容，帮助运维人员管理和排查系统问题。主要功能包括：</p><ul><li>在线用户<br>显示当前在线的用户列表，可以查看用户登录信息和强制下线。</li><li>定时任务<br>管理系统中的定时任务（调度任务），支持任务的新增、编辑、删除，以及手动执行和暂停任务。若依默认使用 Quartz 作为定时任务调度器。</li><li>操作日志<br>记录用户的操作行为，如新增、编辑、删除等操作，便于审计和问题追踪。</li><li>登录日志<br>记录用户的登录历史，包括登录时间、IP 地址、登录状态等信息。</li><li>系统日志<br>显示系统的运行日志，便于运维人员查看和分析问题。</li></ul><h6 id="3-系统工具"><a href="#3-系统工具" class="headerlink" title="3. 系统工具"></a>3. 系统工具</h6><p>提供一些开发和运维相关的工具，帮助开发人员和运维人员提高工作效率。主要功能包括：</p><ul><li>代码生成<br>根据数据库表结构自动生成基础的代码模板，包括 Controller、Service、Mapper、Entity、Vue 页面等，大幅提高开发效率。支持自定义生成策略。</li><li>系统接口<br>提供系统 API 的在线文档，基于 Swagger 生成，支持在线测试和接口文档查看。</li><li>表单构建<br>可视化创建表单，支持生成 Vue 表单页面，简化前端开发工作。</li></ul></blockquote><p><img src="https://api.smain.cn/pics/pic_0ed0d635.png" alt="pic_0ed0d635.png"></p><h5 id="5-若依的代码生成器功能"><a href="#5-若依的代码生成器功能" class="headerlink" title="5.若依的代码生成器功能"></a>5.若依的代码生成器功能</h5><blockquote><p>这里就用到了若依的 generator 模块，若依框架的<code>generator</code>模块是一个代码生成器模块，用于自动生成基础的 CRUD 代码和页面模板。这个模块极大地提高了开发效率，尤其是在开发后台管理系统时，减少了重复性的工作。下面是对<code>generator</code>模块的详细讲解：</p></blockquote><h6 id="1-generator模块的主要功能"><a href="#1-generator模块的主要功能" class="headerlink" title="1. generator模块的主要功能"></a>1. <code>generator</code>模块的主要功能</h6><blockquote><ul><li>根据数据库表结构生成代码：可以通过解析数据库表结构自动生成对应的 Java 代码和 Vue 前端代码，包括 Controller、Service、Mapper、Entity（实体类）以及前端的页面（如列表页、表单页）。</li><li>支持自定义模板：可以根据需求自定义代码生成的模板，灵活控制生成代码的风格和内容。</li><li>可配置性强：支持根据生成选项定制生成的代码，例如是否生成分页查询、是否生成插入、删除、更新方法等。</li><li>大幅减少重复开发工作量：生成的代码可以作为基础模板，开发人员只需根据业务需求做个性化调整即可。</li></ul></blockquote><h6 id="2-generator模块的使用步骤"><a href="#2-generator模块的使用步骤" class="headerlink" title="2. generator模块的使用步骤"></a>2. <code>generator</code>模块的使用步骤</h6><blockquote><h6 id="2-1-进入代码生成器界面"><a href="#2-1-进入代码生成器界面" class="headerlink" title="2.1 进入代码生成器界面"></a>2.1 进入代码生成器界面</h6><ul><li>在后台管理系统中，点击左侧菜单的“系统工具” -&gt; “代码生成”即可进入代码生成器的管理界面。</li><li>该界面显示了所有从数据库中读取的表信息，包括表名、表描述、创建时间等</li></ul></blockquote><h6 id=""><a href="#" class="headerlink" title=""></a><img src="https://api.smain.cn/pics/pic_33165d4b.png" alt="pic_33165d4b.png"></h6><blockquote><h6 id="2-2-配置生成参数"><a href="#2-2-配置生成参数" class="headerlink" title="2.2 配置生成参数"></a>2.2 配置生成参数</h6><p>选择需要生成代码的数据库表后，点击“生成配置”按钮进入配置页面，可以对生成的代码进行一些参数配置：</p><ul><li>生成模块名：可以指定代码所属的模块名称。</li><li>生成包路径：用于指定生成的 Java 代码的包路径。</li><li>生成模板：用于指定表的类型，分别有单表、树表和主子表。</li><li>上级菜单：分配到指定菜单下。</li></ul></blockquote><p><img src="https://api.smain.cn/pics/pic_9ae66709.png" alt="pic_9ae66709.png"></p><blockquote><h6 id="2-3-生成代码"><a href="#2-3-生成代码" class="headerlink" title="2.3 生成代码"></a>2.3 生成代码</h6><ul><li>配置完成后，点击“生成代码”按钮，系统会根据配置自动生成对应的 Java 代码和 Vue 前端代码。</li><li>生成的代码会自动打包成一个压缩文件，包含了后端和前端的代码模板，下载后可以解压并将代码复制到项目中进行个性化修改。</li><li>能够对生成的代码进行预览。</li></ul></blockquote><p><img src="https://api.smain.cn/pics/pic_8d7736e5.png" alt="pic_8d7736e5.png"></p><h6 id="3-生成的代码结构"><a href="#3-生成的代码结构" class="headerlink" title="3. 生成的代码结构"></a>3. 生成的代码结构</h6><blockquote><p>生成的代码分为后端代码和前端代码，具体结构如下：</p><h6 id="3-1-后端代码"><a href="#3-1-后端代码" class="headerlink" title="3.1 后端代码"></a>3.1 后端代码</h6><ul><li>Controller 层：负责处理 HTTP 请求，将请求分发给 Service 层，并将响应结果返回给前端。生成的 Controller 代码包含了基本的 CRUD 操作。</li><li>Service 层：负责业务逻辑的处理。生成的 Service 代码通常包含接口和实现类。</li><li>Mapper 层：MyBatis 的 Mapper 接口，用于执行数据库操作。生成的 Mapper 包含基本的增删改查方法。</li><li>Entity 类：表示数据库表的实体类，与表的结构对应。</li><li>Mapper XML：MyBatis 的 SQL 映射文件，包含了 CRUD 操作的 SQL 语句。</li></ul><h6 id="3-2-前端代码"><a href="#3-2-前端代码" class="headerlink" title="3.2 前端代码"></a>3.2 前端代码</h6><ul><li>列表页面（<code>xxx.vue</code>）：用于显示数据列表，支持分页、查询、增删改等操作。</li><li>新增&#x2F;编辑页面：用于添加和修改数据的表单界面。</li><li>前端接口文件（<code>api/xxx.js</code>）：定义了前端对后端的请求方法，如获取列表数据、添加、删除等操作。</li></ul></blockquote><h6 id="4-代码生成器的自定义"><a href="#4-代码生成器的自定义" class="headerlink" title="4. 代码生成器的自定义"></a>4. 代码生成器的自定义</h6><blockquote><p>若依的<code>generator</code>模块支持自定义模板和生成逻辑，满足不同项目的定制化需求：</p><h6 id="4-1-自定义代码生成模板"><a href="#4-1-自定义代码生成模板" class="headerlink" title="4.1 自定义代码生成模板"></a>4.1 自定义代码生成模板</h6><ul><li>若依的代码生成器使用 Freemarker 模板引擎，所有的生成模板都存放在<code>resources/vm</code>目录下。</li><li>可以根据项目的规范和需求，修改默认模板或者添加新的模板来定制生成的代码格式。</li></ul><h6 id="4-2-自定义生成策略"><a href="#4-2-自定义生成策略" class="headerlink" title="4.2 自定义生成策略"></a>4.2 自定义生成策略</h6><ul><li>可以通过修改代码生成器的实现逻辑，改变代码生成的规则。例如，可以在生成时自动添加业务逻辑或增加额外的注释信息。</li></ul></blockquote><h6 id="5-常见的使用场景"><a href="#5-常见的使用场景" class="headerlink" title="5. 常见的使用场景"></a>5. 常见的使用场景</h6><blockquote><ul><li>快速构建 CRUD 模块：对于后台管理系统，CRUD 模块是常见需求，代码生成器可以大幅减少重复的 CRUD 开发工作。</li><li>原型开发：在项目初期快速生成系统的原型，帮助团队进行功能验证和需求讨论。</li><li>代码模板统一：通过定制模板，可以使项目中的代码风格和规范统一，提高代码的可维护性。</li></ul></blockquote><h4 id="三、自定应化若以框架"><a href="#三、自定应化若以框架" class="headerlink" title="三、自定应化若以框架"></a>三、自定应化若以框架</h4><blockquote><p>前言：这部分内容我将会根据实际业务需求来改造若依框架，内容参考 B 站黑马若依“帝可得”项目教程，对若依原理感兴趣的可以去看一下原视频，个人感觉讲的还是比较清楚的。</p></blockquote><h6 id="1-构建基本框架"><a href="#1-构建基本框架" class="headerlink" title="1.构建基本框架"></a>1.构建基本框架</h6><blockquote><p>首先让我们来创建三张表，下面是建表语句：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `tb_region` (</span><br><span class="line">  `id` INT AUTO_INCREMENT COMMENT <span class="string">&#x27;主键id&#x27;</span> PRIMARY KEY,</span><br><span class="line">  `region_name` VARCHAR(<span class="number">255</span>) NOT NULL COMMENT <span class="string">&#x27;区域名称&#x27;</span>,</span><br><span class="line">  `create_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `create_by` VARCHAR(<span class="number">64</span>) COMMENT <span class="string">&#x27;创建人&#x27;</span>,</span><br><span class="line">  `update_by` VARCHAR(<span class="number">64</span>) COMMENT <span class="string">&#x27;修改人&#x27;</span>,</span><br><span class="line">  `remark` TEXT COMMENT <span class="string">&#x27;备注&#x27;</span></span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=<span class="string">&#x27;区域表&#x27;</span>;</span><br><span class="line"></span><br><span class="line">-- 插入测试数据</span><br><span class="line">INSERT INTO `tb_region` (`region_name`,`remark`) VALUES (<span class="string">&#x27;北京市朝阳区&#x27;</span>,<span class="string">&#x27;北京市朝阳区&#x27;</span>), (<span class="string">&#x27;北京市海淀区&#x27;</span>,<span class="string">&#x27;北京市海淀区&#x27;</span>), (<span class="string">&#x27;北京市东城区&#x27;</span>,<span class="string">&#x27;北京市东城区&#x27;</span>);</span><br><span class="line"></span><br><span class="line">CREATE TABLE `tb_partner` (</span><br><span class="line">  `id` INT AUTO_INCREMENT COMMENT <span class="string">&#x27;主键id&#x27;</span> PRIMARY KEY,</span><br><span class="line">  `partner_name` VARCHAR(<span class="number">255</span>) NOT NULL COMMENT <span class="string">&#x27;合作商名称&#x27;</span>,</span><br><span class="line">  `contact_person` VARCHAR(<span class="number">64</span>) COMMENT <span class="string">&#x27;联系人&#x27;</span>,</span><br><span class="line">  `contact_phone` VARCHAR(<span class="number">15</span>) COMMENT <span class="string">&#x27;联系电话&#x27;</span>,</span><br><span class="line">  `profit_ratio` INT COMMENT <span class="string">&#x27;分成比例&#x27;</span>,</span><br><span class="line">  `account` VARCHAR(<span class="number">64</span>) COMMENT <span class="string">&#x27;账号&#x27;</span>,</span><br><span class="line">  `password` VARCHAR(<span class="number">64</span>) COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  `create_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `create_by` VARCHAR(<span class="number">64</span>) COMMENT <span class="string">&#x27;创建人&#x27;</span>,</span><br><span class="line">  `update_by` VARCHAR(<span class="number">64</span>) COMMENT <span class="string">&#x27;修改人&#x27;</span>,</span><br><span class="line">  `remark` TEXT COMMENT <span class="string">&#x27;备注&#x27;</span></span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=<span class="string">&#x27;合作商表&#x27;</span>;</span><br><span class="line"></span><br><span class="line">-- 插入测试数据</span><br><span class="line">INSERT INTO `tb_partner` (`partner_name`, `contact_person`, `contact_phone`, `profit_ratio`, `account`, `password`) VALUES</span><br><span class="line">(<span class="string">&#x27;合作商A&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;13800138000&#x27;</span>, <span class="number">30</span>, <span class="string">&#x27;a001&#x27;</span>, <span class="string">&#x27;pwdA&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;合作商B&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;13912345678&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;b002&#x27;</span>, <span class="string">&#x27;pwdB&#x27;</span>);</span><br><span class="line"></span><br><span class="line">CREATE TABLE `tb_node` (</span><br><span class="line">  `id` INT AUTO_INCREMENT COMMENT <span class="string">&#x27;主键id&#x27;</span> PRIMARY KEY,</span><br><span class="line">  `node_name` VARCHAR(<span class="number">255</span>) NOT NULL COMMENT <span class="string">&#x27;点位名称&#x27;</span>,</span><br><span class="line">  `address` VARCHAR(<span class="number">255</span>) NOT NULL COMMENT <span class="string">&#x27;详细地址&#x27;</span>,</span><br><span class="line">  `business_type` INT COMMENT <span class="string">&#x27;商圈类型&#x27;</span>,</span><br><span class="line">  `region_id` INT COMMENT <span class="string">&#x27;区域ID&#x27;</span>,</span><br><span class="line">  `partner_id` INT COMMENT <span class="string">&#x27;合作商ID&#x27;</span>,</span><br><span class="line">  `create_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `create_by` VARCHAR(<span class="number">64</span>) COMMENT <span class="string">&#x27;创建人&#x27;</span>,</span><br><span class="line">  `update_by` VARCHAR(<span class="number">64</span>) COMMENT <span class="string">&#x27;修改人&#x27;</span>,</span><br><span class="line">  `remark` TEXT COMMENT <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">  FOREIGN <span class="title function_">KEY</span> <span class="params">(`region_id`)</span> REFERENCES `tb_region`(`id`) ON DELETE CASCADE ON UPDATE CASCADE,</span><br><span class="line">  FOREIGN <span class="title function_">KEY</span> <span class="params">(`partner_id`)</span> REFERENCES `tb_partner`(`id`) ON DELETE CASCADE ON UPDATE CASCADE</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=<span class="string">&#x27;点位表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 插入测试数据</span><br><span class="line">-- 假设区域ID为<span class="number">1</span>对应<span class="string">&#x27;北京市朝阳区&#x27;</span>，合作商ID为<span class="number">1</span>对应<span class="string">&#x27;合作商A&#x27;</span></span><br><span class="line">INSERT INTO `tb_node` (`node_name`, `address`, `business_type`, `region_id`, `partner_id`) VALUES</span><br><span class="line">(<span class="string">&#x27;三里屯点位&#x27;</span>, <span class="string">&#x27;北京市朝阳区三里屯路&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;五道口点位&#x27;</span>, <span class="string">&#x27;北京市海淀区五道口&#x27;</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><blockquote><p>然后是这三张表之间的关系：可以看到区域表跟点位表是一对多的关系，合作商表与点位表也是一对多的关系，一个区域里面或者是一个合作商都可以拥有多个点位。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_a0178a50.png" alt="pic_a0178a50.png"></p><blockquote><p>然后我们使用若依的代码生成器来生成区域管理相关代码</p></blockquote><p><img src="https://api.smain.cn/pics/pic_95dbd639.png" alt="pic_95dbd639.png"></p><p><img src="https://api.smain.cn/pics/pic_19566da6.png" alt="pic_19566da6.png"></p><p><img src="https://api.smain.cn/pics/pic_a1491b66.png" alt="pic_a1491b66.png"></p><blockquote><p>然后将生成的代码分别导入到你的前后端项目中，main 文件夹中生成的后端代码，vue 文件夹中生成的前端代码，下面的三条 sql 脚本是若依框架的动态菜单表，将这三张表导入以后就可以使用若依的菜单管理功能对这三张菜单进行动态管理。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_72575bda.png" alt="pic_72575bda.png"></p><p><img src="https://api.smain.cn/pics/pic_0f44480a.png" alt="pic_0f44480a.png"> <img src="https://api.smain.cn/pics/pic_97c44b56.png" alt="pic_97c44b56.png"></p><blockquote><p>然后启动项目进入到区域管理菜单模块，基础界面如下图所示：</p></blockquote><p><img src="https://api.smain.cn/pics/pic_61267570.png" alt="pic_61267570.png"></p><h6 id="2-自定义框架"><a href="#2-自定义框架" class="headerlink" title="2.自定义框架"></a>2.自定义框架</h6><h6 id="2-1-问题分析"><a href="#2-1-问题分析" class="headerlink" title="2.1 问题分析"></a>2.1 问题分析</h6><blockquote><p>可以看到，若依帮我们生成的代码还是有很多问题的：</p></blockquote><blockquote><p>1.首先就是列表名 id，用 id 来当列表名其实是若依默认的，但这显然是不合适的的，所以我们要把 id 改为序号。</p><p>2.其次就是我们在刚刚建表时就对这三张表分析过了，区域表显然是更点位表有关联的，但是在页面上并没有体现出来，我们是想要在区域菜单中展示对应区域有多少个点位的！</p><p>3.除了基本的修改和删除，如果我还想要增加一个按键叫做“查看详情”，要求点击该按键后弹出该区域的详细信息因该怎么实现？</p></blockquote><h6 id="2-2-解决方法"><a href="#2-2-解决方法" class="headerlink" title="2.2 解决方法"></a>2.2 解决方法</h6><blockquote><p>下面我们针对这些问题一一来解决</p></blockquote><blockquote><p>首先是序号名称问题，我们将 lable 标签中的值修改掉就好了</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;el-table-column label=<span class="string">&quot;序号&quot;</span> align=<span class="string">&quot;center&quot;</span> prop=<span class="string">&quot;id&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><blockquote><p>然后是对应区域点位数量的问题，这个问题我们需要将其拆封成两个部分，第一部分是后端的视图封装，我们定义一个 RegionVo 类，来封装所要在前端展示的数据，由前面的分析可知我们希望展示点位数据，所以先继承原有的 Regon 类，然后在此基础上添加一个 nodeCount 变量用来存储对应的点位数量（变量名的定义因该尽量跟数据库对应数据类型的名字一样，并采用驼峰式命名风格）</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 使用驼峰命名法转换字段 --&gt;</span><br><span class="line">&lt;setting name=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> value=<span class="string">&quot;true&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p><img src="https://api.smain.cn/pics/pic_549657fb.png" alt="pic_549657fb.png"></p><blockquote><p>然后就是实现点位数量的查询，这里有两种实现思路</p><p>（1）同步存储：在区域表中有点位数的字段，当点位发生变化时，同步区域表中的点位数。</p><ul><li>优点：由于是单表查询操作，查询列表效率最高。</li><li>缺点：需要在点位增删改时修改区域表中的数据，有额外的开销，数据也可能不一致。</li></ul><p>（2）关联查询：编写关联查询语句，在 mapper 层封装。</p><ul><li>优点：实时查询，数据 100%正确，不需要单独维护。</li><li>缺点：SQL 语句较复杂，如果数据量大，性能比较低。</li></ul><p>由于区域和点位表，记录个数都不是很多，所以我们采用关联查询这种方案。</p></blockquote><blockquote><p>SQL 查询：先聚合统计每个区域的点位数，然后与区域表进行关联查询</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select r.id, r.region_name, r.remark, ifnull(n.node_count, <span class="number">0</span>) as node_count</span><br><span class="line">from  tb_region r left <span class="title function_">join</span></span><br><span class="line"><span class="params">(select region_id, count(*)</span> as node_count</span><br><span class="line">from tb_node group by region_id) n on r.id = n.region_id</span><br></pre></td></tr></table></figure><blockquote><p>先在查询中测试这段 sql 代码，运行结果没问题后再放入 mapper.xml 中。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_dd2a6197.png" alt="pic_dd2a6197.png"></p><p><img src="https://api.smain.cn/pics/pic_c878a3e5.png" alt="pic_c878a3e5.png"></p><blockquote><p>加 where 的原因是为了动态地生成 SQL 查询的 <code>WHERE</code> 子句，它可以帮助避免因条件拼接时的语法错误，自动处理 <code>WHERE</code> 关键字和 <code>AND</code> 的连接问题。</p></blockquote><blockquote><p>然后即使基本的 mapper 层、service 层、servviceipml 层、controller 层的编写，这里就快速过一下代码。</p></blockquote><p>RegionMapper</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询区域管理列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> region</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> RegionVo集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;RegionVo&gt; <span class="title function_">selectRegionVoList</span><span class="params">(Region region)</span>;</span><br></pre></td></tr></table></figure><p>IRegionService</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询区域管理列表，带点位数量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> region 区域管理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> RegionVo集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> List&lt;RegionVo&gt; <span class="title function_">selectRegionVoList</span><span class="params">(Region region)</span>;</span><br></pre></td></tr></table></figure><p>RegionServiceImpl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询区域管理列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> region</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> RegionVo集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;RegionVo&gt; <span class="title function_">selectRegionVoList</span><span class="params">(Region region)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> regionMapper.selectRegionVoList(region);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RegionController</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询区域管理列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;@ss.hasPermi(&#x27;manage:region:list&#x27;)&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> TableDataInfo <span class="title function_">list</span><span class="params">(Region region)</span></span><br><span class="line">&#123;</span><br><span class="line">    startPage();</span><br><span class="line">    List&lt;RegionVo&gt; voList = regionService.selectRegionVoList(region);</span><br><span class="line">    <span class="keyword">return</span> getDataTable(voList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>到此后端代码改造完成，需要注意的是，除了在 Controller 层中对原有的 list 方法进行修改以外，剩下的几层都是新增方法，不要把之前的方法改掉！不然由于有一些接口比如数据导出，还是使用的 selectRegionList（）方法就会报错！</p></blockquote><blockquote><p>接下来让我们把目光转向前端，由于后端已经数据封装好了，这里只需要在 el-table-column 标签中指定 prop 属性即可。</p></blockquote><p>region&#x2F;index.vue</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;el-table-column label=<span class="string">&quot;点位数&quot;</span> align=<span class="string">&quot;center&quot;</span> prop=<span class="string">&quot;nodeCount&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><blockquote><p>修改完成后重新启动项目查看界面，没有问题点位数据成功显示！</p></blockquote><p><img src="https://api.smain.cn/pics/pic_884739fb.png" alt="pic_884739fb.png"></p><blockquote><p>没有显示成功的可以打开 F12 然后点击一下重置按钮看一下数据返回没有，如果有下面的数据就证明后端没有问题，检查前端代码写错没有，如果连数据都没有返回，就证明是后端代码哪里写错了，以我的经验来看一般都是数据库查询的时候出问题。</p></blockquote><blockquote><p>遇到 bug 的时候不要怕！根据报错信息一步步寻找错误，学会使用断点进行调试和 log.info(需用引入 SLF4J 依赖)输出日志信息，修改 bug 的过程就是你对项目结构进一步加深了解的过程！</p></blockquote><p><img src="https://api.smain.cn/pics/pic_c82ce8dc.png" alt="pic_c82ce8dc.png"></p><blockquote><p>最后我们来填第三个坑，实现查看详情按钮。</p></blockquote><blockquote><p>还是先来分析一下，我们最后想要实现下图的效果，点击查询详情后弹出下面的提示框，提示框中显示了区域名称和包含的点位，显然点位是用一个 List<NodeVo> 对象来存储的，这里又涉及到一个坑了，设备数量在哪里呢？这里为了不再增加复杂度并且考虑到连贯性的关系，就不再对点位表进行改造了，我们修改一下需求，只显示区域包括的点位名称，不显示设备数量。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_9bd96557.png" alt="pic_9bd96557.png"></p><blockquote><p>要查询点位数据，我们就要用到前端的 node.js 中的 listNode 方法</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询点位管理列表</span></span><br><span class="line">export function <span class="title function_">listNode</span><span class="params">(query)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> request(&#123;</span><br><span class="line">    url: <span class="string">&#x27;/manage/node/list&#x27;</span>,</span><br><span class="line">    method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    params: query</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>该方法调用后端的 list 方法查询点位数据</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询点位管理列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@PreAuthorize(&quot;@ss.hasPermi(&#x27;manage:node:list&#x27;)&quot;)</span></span><br><span class="line"> <span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> TableDataInfo <span class="title function_">list</span><span class="params">(Node node)</span></span><br><span class="line">    &#123;</span><br><span class="line">        startPage();</span><br><span class="line">        List&lt;Node&gt; list = nodeService.selectNodeList(node);</span><br><span class="line">        <span class="keyword">return</span> getDataTable(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后我们在<code>&lt;script&gt;</code>中来编写 <code>getRegionInfo</code> 方法，并绑定按键</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-button</span></span></span><br><span class="line"><span class="tag">  <span class="attr">link</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">click</span>=<span class="string">&quot;getRegionInfo(scope.row)&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-hasPermi</span>=<span class="string">&quot;[&#x27;manage:node:list&#x27;]&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span>查看详情&lt;/el-button</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><blockquote><p>记得引入 js 代码</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  listRegion,</span><br><span class="line">  getRegion,</span><br><span class="line">  delRegion,</span><br><span class="line">  addRegion,</span><br><span class="line">  updateRegion,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;@/api/manage/region&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; listNode &#125; <span class="keyword">from</span> <span class="string">&quot;@/api/manage/node&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; loadAllParams &#125; <span class="keyword">from</span> <span class="string">&quot;@/api/page&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 查看详情按钮操作 */</span></span><br><span class="line"><span class="keyword">const</span> nodeList = <span class="title function_">ref</span>([]);</span><br><span class="line"><span class="keyword">const</span> regionInfoOpen = <span class="title function_">ref</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getRegionInfo</span>(<span class="params">row</span>) &#123;</span><br><span class="line">  <span class="comment">// 查询区域信息</span></span><br><span class="line">  <span class="title function_">reset</span>();</span><br><span class="line">  <span class="keyword">const</span> _id = row.<span class="property">id</span>;</span><br><span class="line">  <span class="title function_">getRegion</span>(_id).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    form.<span class="property">value</span> = response.<span class="property">data</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 查询点位列表</span></span><br><span class="line">  loadAllParams.<span class="property">regionId</span> = row.<span class="property">id</span>;</span><br><span class="line">  <span class="title function_">listNode</span>(loadAllParams).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    nodeList.<span class="property">value</span> = response.<span class="property">rows</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  regionInfoOpen.<span class="property">value</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>下面是对这一段 javascript 代码的详细解释，本问题的关键所在就是这段代码，有了这段代码才能够拿到数据。</p><ol><li><code>const nodeList = ref([]);</code></li></ol><ul><li>这行代码定义了一个响应式变量 <code>nodeList</code>，初始值为空数组。</li><li><code>ref</code> 是 Vue.js Composition API 提供的用于创建响应式数据的函数，<code>nodeList</code> 会随着值的变化自动触发视图更新。</li></ul><ol start="2"><li><code>const regionInfoOpen = ref(false);</code></li></ol><ul><li>定义了另一个响应式变量 <code>regionInfoOpen</code>，初始值为 <code>false</code>。</li><li>这个变量用来控制区域信息详情的显示状态，当 <code>regionInfoOpen</code> 为 <code>true</code> 时，详情会显示。</li></ul><ol start="3"><li><code>function getRegionInfo(row) &#123; ... &#125;</code></li></ol><ul><li>定义了一个函数 <code>getRegionInfo</code>，用于处理查看区域详情的操作。</li><li>参数 <code>row</code> 是一个对象，通常表示区域的某一行数据。</li></ul><ol start="4"><li><code>reset();</code></li></ol><ul><li>调用了一个 <code>reset()</code> 函数，可能用于重置表单或页面状态，以清除之前的数据。具体的实现不在这段代码中。</li></ul><ol start="5"><li><code>const _id = row.id</code></li></ol><ul><li>获取 <code>row</code> 对象的 <code>id</code> 属性值，并将其存储在 <code>_id</code> 变量中，用于后续的查询操作。</li></ul><ol start="6"><li><code>getRegion(_id).then(response =&gt; &#123; ... &#125;)</code></li></ol><ul><li>调用 <code>getRegion</code> 方法获取区域的详细信息，<code>_id</code> 作为查询参数。</li><li><code>getRegion</code> 应该是一个返回 Promise 的函数，使用 <code>.then</code> 方法处理异步响应。</li><li>如果请求成功，<code>response.data</code> 会赋值给 <code>form.value</code>，其中 <code>form</code> 应该是另一个 <code>ref</code> 响应式变量，用于绑定表单数据。</li></ul><ol start="7"><li><code>loadAllParams.regionId = row.id;</code></li></ol><ul><li>更新 <code>loadAllParams</code> 对象的 <code>regionId</code> 属性为当前区域的 <code>id</code>，用于查询点位列表。</li></ul><ol start="8"><li><code>listNode(loadAllParams).then(response =&gt; &#123; ... &#125;)</code></li></ol><ul><li>调用 <code>listNode</code> 方法获取与当前区域相关的点位列表，<code>loadAllParams</code> 作为查询参数。</li><li><code>listNode</code> 也是一个返回 Promise 的函数，异步处理响应结果。</li><li>请求成功时，将返回的数据（<code>response.rows</code>）赋值给 <code>nodeList.value</code>，更新点位列表。</li></ul><ol start="9"><li><code>regionInfoOpen.value = true;</code></li></ol><ul><li>将 <code>regionInfoOpen</code> 的值设置为 <code>true</code>，表示区域信息详情的弹窗或面板应该显示。</li></ul></blockquote><blockquote><p>理解完了这段代码后，最后就是编写一个提示框，绑定对应的数据即可！</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 查看详情对话框 --&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">el-dialog</span> <span class="attr">title</span>=<span class="string">&quot;区域详情&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;regionInfoOpen&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500px&quot;</span> <span class="attr">append-to-body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;区域名称&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;regionName&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;form.regionName&quot;</span> <span class="attr">disabled</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">label</span>&gt;</span>包含点位：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">el-table</span> <span class="attr">:data</span>=<span class="string">&quot;nodeList&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">&quot;序号&quot;</span> <span class="attr">type</span>=<span class="string">&quot;index&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">&quot;点位名称&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;nodeName&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">el-dialog</span>&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>欧克，做完这一步之后就可以重新启动项目进行测试了。</p></blockquote><p><img src="https://api.smain.cn/pics/pic_92b16645.png" alt="pic_92b16645.png"></p><blockquote><p>可以看到点击查看详情后成功返回提示框！</p></blockquote><blockquote><p>到此，自定义若依框架的一些基本步骤都已经演示完毕，如果你认真的看到了这里并且自己动手试验了，那么我相信你一定对若依框架有了更深刻的了解和认识，当然，由于本文只是若依的基础入门讲解，所以只是定义了一些基础的功能，若依能做的远远不止这些，例如定时任务调度，数据可视化报表等等，笔者也是水平有限，如果有什么错误敬请指正，希望能和大家一起学习一起进步！</p></blockquote><h4 id="四、结语"><a href="#四、结语" class="headerlink" title="四、结语"></a>四、结语</h4><blockquote><p>到这里，若依框架的基本使用方法已经介绍完毕。需要注意的是，虽然若依的代码生成器极大地提高了开发效率，方便快捷地生成基本的增删改查功能，但对于较为复杂的业务场景，例如多表联查或复杂的业务逻辑处理，仍需要开发者自行进行调整和优化。这也为我们提供了更多的灵活性，可以根据实际需求对代码进行更深入的定制化开发。</p></blockquote><blockquote><p>前路漫漫道阻且长，砥砺前行与君共勉！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
